<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sistema de Planeaci√≥n de Reforestaciones</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #e8f5e8 0%, #c8e6c9 50%, #a5d6a7 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            color: #2e7d32;
        }

        .header {
            background: linear-gradient(135deg, #ffffff 0%, #f1f8e9 100%);
            padding: 1.5rem 2rem;
            box-shadow: 0 4px 20px rgba(46, 125, 50, 0.15);
            border-bottom: 3px solid #66bb6a;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .logo-section {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .company-logo {
            height: 60px;
            width: auto;
        }

        .header-text {
            display: flex;
            flex-direction: column;
        }

        .header h1 {
            color: #1b5e20;
            font-size: 1.8rem;
            font-weight: 600;
            margin: 0;
            letter-spacing: -0.5px;
        }

        .header .subtitle {
            color: #388e3c;
            font-size: 0.9rem;
            font-weight: 400;
            margin-top: 0.2rem;
            opacity: 0.9;
        }

        .main-container {
            display: flex;
            flex: 1;
            gap: 1.5rem;
            padding: 1.5rem;
            min-height: 0;
        }

        .sidebar {
            width: 350px;
            background: linear-gradient(135deg, #ffffff 0%, #f9fbe7 100%);
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 8px 32px rgba(46, 125, 50, 0.12);
            border: 1px solid rgba(102, 187, 106, 0.2);
            overflow-y: auto;
            max-height: calc(100vh - 180px);
        }

        .workspace {
            flex: 1;
            background: linear-gradient(135deg, #ffffff 0%, #f9fbe7 100%);
            border-radius: 12px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 8px 32px rgba(46, 125, 50, 0.12);
            border: 1px solid rgba(102, 187, 106, 0.2);
        }

        .workspace-header {
            background: linear-gradient(135deg, #2e7d32 0%, #388e3c 100%);
            color: white;
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
            box-shadow: 0 2px 8px rgba(46, 125, 50, 0.2);
        }

        .workspace-title {
            font-size: 1.1rem;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            height: calc(100vh - 220px);
            overflow: hidden;
            background: linear-gradient(135deg, #f1f8e9 0%, #e8f5e8 100%);
            cursor: grab;
        }

        .canvas-container:active {
            cursor: grabbing;
        }

        .main-canvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
        }

        .section {
            margin-bottom: 1.8rem;
            background: linear-gradient(135deg, #ffffff 0%, #f1f8e9 100%);
            border-radius: 10px;
            padding: 1.2rem;
            border: 1px solid rgba(102, 187, 106, 0.15);
            box-shadow: 0 2px 8px rgba(46, 125, 50, 0.08);
        }

        .section h3 {
            color: #1b5e20;
            margin-bottom: 1rem;
            font-size: 1rem;
            font-weight: 600;
            border-bottom: 2px solid #81c784;
            padding-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn {
            background: linear-gradient(135deg, #4caf50 0%, #66bb6a 100%);
            color: white;
            border: none;
            padding: 0.7rem 1.2rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.3s ease;
            margin: 0.3rem;
            box-shadow: 0 3px 12px rgba(76, 175, 80, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
            background: linear-gradient(135deg, #66bb6a 0%, #81c784 100%);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #81c784 0%, #a5d6a7 100%);
            box-shadow: 0 3px 12px rgba(129, 199, 132, 0.3);
        }

        .btn-secondary:hover {
            background: linear-gradient(135deg, #a5d6a7 0%, #c8e6c9 100%);
            box-shadow: 0 6px 20px rgba(129, 199, 132, 0.4);
        }

        .btn-danger {
            background: linear-gradient(135deg, #e57373 0%, #ef5350 100%);
            box-shadow: 0 3px 12px rgba(229, 115, 115, 0.3);
        }

        .btn-danger:hover {
            background: linear-gradient(135deg, #ef5350 0%, #f44336 100%);
            box-shadow: 0 6px 20px rgba(229, 115, 115, 0.4);
        }

        .file-input {
            margin-bottom: 1rem;
        }

        .file-input input[type="file"] {
            display: none;
        }

        .file-input label {
            display: inline-block;
            background: linear-gradient(135deg, #26a69a 0%, #4db6ac 100%);
            color: white;
            padding: 0.7rem 1.2rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 3px 12px rgba(38, 166, 154, 0.3);
            font-weight: 500;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .file-input label:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(38, 166, 154, 0.4);
            background: linear-gradient(135deg, #4db6ac 0%, #80cbc4 100%);
        }

        .tree-types {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.8rem;
        }

        .tree-category-section {
            margin-bottom: 1.5rem;
        }

        .tree-category-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: #1b5e20;
            margin-bottom: 0.8rem;
            padding: 0.8rem;
            background: linear-gradient(135deg, #e8f5e8 0%, #c8e6c9 100%);
            border-radius: 6px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid rgba(102, 187, 106, 0.3);
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
        }

        .tree-category-title:hover {
            background: linear-gradient(135deg, #c8e6c9 0%, #a5d6a7 100%);
            border-color: #66bb6a;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 187, 106, 0.2);
        }

        .tree-category-title.collapsed {
            border-radius: 6px 6px 6px 6px;
        }

        .tree-category-title.expanded {
            border-radius: 6px 6px 0 0;
            border-bottom: none;
        }

        .dropdown-arrow {
            font-size: 0.8rem;
            transition: transform 0.3s ease;
            color: #2e7d32;
            font-weight: bold;
        }

        .dropdown-arrow.expanded {
            transform: rotate(180deg);
        }

        .tree-types-container {
            max-height: 0;
            overflow: hidden;
            transition: all 0.3s ease;
            border: 2px solid rgba(102, 187, 106, 0.3);
            border-top: none;
            border-radius: 0 0 6px 6px;
            background: linear-gradient(135deg, #ffffff 0%, #f9fbe7 100%);
        }

        .tree-types-container.expanded {
            max-height: 300px;
            padding: 1rem;
            overflow-y: auto;
        }

        /* Custom Scrollbar for Tree Containers */
        .tree-types-container::-webkit-scrollbar {
            width: 6px;
        }

        .tree-types-container::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }

        .tree-types-container::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 3px;
            transition: background 0.3s ease;
        }

        .tree-types-container::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }

        /* For Firefox */
        .tree-types-container {
            scrollbar-width: thin;
            scrollbar-color: #c1c1c1 #f1f1f1;
        }

        .tree-item {
            background: linear-gradient(135deg, #ffffff 0%, #f1f8e9 100%);
            border: 2px solid rgba(102, 187, 106, 0.2);
            border-radius: 12px;
            padding: 0.8rem;
            text-align: center;
            cursor: grab;
            transition: all 0.3s ease;
            position: relative;
            box-shadow: 0 2px 8px rgba(46, 125, 50, 0.08);
        }

        .tree-item:hover {
            border-color: #66bb6a;
            transform: translateY(-3px);
            box-shadow: 0 8px 24px rgba(102, 187, 106, 0.25);
            background: linear-gradient(135deg, #ffffff 0%, #e8f5e8 100%);
        }

        .tree-item:active {
            cursor: grabbing;
        }

        .tree-icon {
            width: 35px;
            height: 35px;
            margin: 0 auto 0.4rem;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3rem;
            color: white;
            box-shadow: 0 3px 12px rgba(0,0,0,0.2);
        }

        .tree-nuevo { background: linear-gradient(135deg, #4caf50 0%, #66bb6a 100%); }
        .tree-existente { background: linear-gradient(135deg, #2196f3 0%, #42a5f5 100%); }

        .tree-name {
            font-weight: 600;
            font-size: 0.75rem;
            color: #1b5e20;
            margin-bottom: 0.1rem;
        }

        .tree-size {
            font-size: 0.7rem;
            color: #388e3c;
            font-weight: 500;
            opacity: 0.8;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 0.6rem;
            margin-bottom: 1rem;
        }

        .input-group {
            margin-bottom: 1rem;
        }

        .input-group label {
            display: block;
            margin-bottom: 0.4rem;
            font-weight: 600;
            color: #1b5e20;
            font-size: 0.9rem;
        }

        .input-group input {
            width: 100%;
            padding: 0.7rem;
            border: 2px solid rgba(102, 187, 106, 0.3);
            border-radius: 8px;
            font-size: 0.9rem;
            background: linear-gradient(135deg, #ffffff 0%, #f9fbe7 100%);
            transition: all 0.3s ease;
        }

        .input-group input:focus {
            outline: none;
            border-color: #66bb6a;
            box-shadow: 0 0 0 3px rgba(102, 187, 106, 0.1);
        }

        .toggle-container {
            display: flex;
            align-items: center;
            gap: 0.8rem;
            margin-bottom: 0.8rem;
            padding: 0.5rem 0;
        }

        .toggle {
            position: relative;
            display: inline-block;
            width: 52px;
            height: 28px;
        }

        .toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #e0e0e0 0%, #bdbdbd 100%);
            transition: .4s;
            border-radius: 28px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 22px;
            width: 22px;
            left: 3px;
            bottom: 3px;
            background: linear-gradient(135deg, #ffffff 0%, #f5f5f5 100%);
            transition: .4s;
            border-radius: 50%;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }

        input:checked + .slider {
            background: linear-gradient(135deg, #66bb6a 0%, #4caf50 100%);
        }

        input:checked + .slider:before {
            transform: translateX(24px);
        }

        .toggle-label {
            font-weight: 500;
            color: #2e7d32;
            font-size: 0.9rem;
        }

        .status-bar {
            background: linear-gradient(135deg, #1b5e20 0%, #2e7d32 100%);
            color: white;
            padding: 0.8rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
            font-weight: 500;
            box-shadow: 0 -2px 8px rgba(46, 125, 50, 0.2);
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(27, 94, 32, 0.4);
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: linear-gradient(135deg, #ffffff 0%, #f1f8e9 100%);
            margin: 3% auto;
            padding: 2.5rem;
            border-radius: 16px;
            width: 90%;
            max-width: 600px;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(46, 125, 50, 0.3);
            border: 1px solid rgba(102, 187, 106, 0.2);
            position: relative;
        }

        .modal-content::-webkit-scrollbar {
            width: 8px;
        }

        .modal-content::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }

        .modal-content::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #66bb6a 0%, #4caf50 100%);
            border-radius: 10px;
        }

        .modal-content::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #4caf50 0%, #388e3c 100%);
        }

        .modal-content h2 {
            color: #1b5e20;
            margin-bottom: 1.5rem;
            font-weight: 600;
            border-bottom: 3px solid #81c784;
            padding-bottom: 0.5rem;
        }

        .close {
            color: #388e3c;
            float: right;
            font-size: 32px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .close:hover {
            color: #1b5e20;
            transform: scale(1.1);
        }

        .report-section {
            margin-bottom: 1.5rem;
            padding: 1.2rem;
            background: linear-gradient(135deg, #f1f8e9 0%, #e8f5e8 100%);
            border-radius: 10px;
            border: 1px solid rgba(102, 187, 106, 0.2);
        }

        .report-section h4 {
            color: #1b5e20;
            margin-bottom: 0.8rem;
            font-weight: 600;
        }

        .alert {
            padding: 1rem;
            margin-bottom: 1rem;
            border-radius: 10px;
            font-weight: 500;
            border-left: 4px solid;
        }

        .alert-warning {
            background: linear-gradient(135deg, #fff8e1 0%, #fff3c4 100%);
            border-left-color: #ffb74d;
            color: #e65100;
        }

        .alert-success {
            background: linear-gradient(135deg, #e8f5e8 0%, #c8e6c9 100%);
            border-left-color: #66bb6a;
            color: #1b5e20;
        }

        .tree-size-small { font-size: 0.65rem; }

        .project-name-container {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex: 1;
        }

        .project-name-display {
            font-size: 1.1rem;
            font-weight: 500;
            color: white;
            cursor: pointer;
            padding: 0.3rem 0.5rem;
            border-radius: 4px;
            transition: background-color 0.2s ease;
        }

        .project-name-display:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .project-name-input {
            font-size: 1.1rem;
            font-weight: 500;
            color: #1b5e20;
            background: white;
            border: 2px solid #66bb6a;
            border-radius: 4px;
            padding: 0.3rem 0.5rem;
            outline: none;
            min-width: 200px;
        }

        .project-name-input:focus {
            border-color: #4caf50;
            box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.2);
        }

        .edit-project-btn {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            font-size: 0.9rem;
            transition: background-color 0.2s ease;
            opacity: 0.7;
        }

        .edit-project-btn:hover {
            background-color: rgba(255, 255, 255, 0.1);
            opacity: 1;
        }

        .save-project-btn {
            background: #4caf50;
            border: none;
            color: white;
            cursor: pointer;
            padding: 0.3rem 0.6rem;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 500;
            transition: background-color 0.2s ease;
        }

        .save-project-btn:hover {
            background: #66bb6a;
        }

        .legend {
            position: absolute;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #ffffff 0%, #f9fbe7 100%);
            border-radius: 12px;
            padding: 1rem;
            box-shadow: 0 8px 32px rgba(46, 125, 50, 0.15);
            border: 2px solid rgba(102, 187, 106, 0.3);
            min-width: 200px;
            font-size: 0.85rem;
            z-index: 100;
        }

        .legend h4 {
            color: #1b5e20;
            margin-bottom: 0.8rem;
            margin-right: 0;
            font-size: 0.9rem;
            font-weight: 600;
            text-align: left;
            border-bottom: 2px solid #81c784;
            padding-bottom: 0.3rem;
            padding-right: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .legend-close-btn {
            background: none;
            border: none;
            color: #388e3c;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 3px;
            transition: all 0.2s ease;
            margin-right: 0;
            line-height: 1;
        }

        .legend-close-btn:hover {
            background: rgba(56, 142, 60, 0.1);
            color: #1b5e20;
            transform: scale(1.1);
        }

        .legend-section {
            margin-bottom: 0.8rem;
        }

        .legend-section h5 {
            color: #2e7d32;
            font-size: 0.8rem;
            font-weight: 600;
            margin-bottom: 0.4rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.3rem;
            font-size: 0.75rem;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 1px solid rgba(0,0,0,0.2);
            flex-shrink: 0;
        }

        .legend-line {
            width: 20px;
            height: 3px;
            flex-shrink: 0;
            border-radius: 2px;
        }

        .legend-polygon {
            width: 16px;
            height: 16px;
            flex-shrink: 0;
            border: 2px solid #007bff;
            background: rgba(0, 123, 255, 0.2);
            border-radius: 2px;
        }

        .legend-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background: #4caf50;
            color: white;
            border: none;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
            z-index: 101;
        }

        .legend-toggle:hover {
            background: #66bb6a;
            transform: scale(1.1);
        }

        .legend.collapsed {
            display: none;
        }

        .legend-toggle.collapsed {
            display: flex;
        }

        /* TOAST NOTIFICATIONS STYLES */
        .toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 9999;
            display: flex;
            flex-direction: column-reverse;
            gap: 10px;
            max-width: 400px;
            pointer-events: none;
        }

        .toast {
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            border-radius: 12px;
            padding: 16px 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
            border-left: 4px solid;
            display: flex;
            align-items: center;
            gap: 12px;
            min-width: 320px;
            max-width: 400px;
            transform: translateX(420px);
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            opacity: 0;
            pointer-events: auto;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .toast.show {
            transform: translateX(0);
            opacity: 1;
        }

        .toast.hide {
            transform: translateX(420px);
            opacity: 0;
        }

        .toast::before {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            height: 3px;
            background: inherit;
            animation: toast-progress 5s linear forwards;
            border-radius: 0 0 12px 12px;
        }

        @keyframes toast-progress {
            from { width: 100%; }
            to { width: 0%; }
        }

        .toast.paused::before {
            animation-play-state: paused;
        }

        .toast-icon {
            font-size: 20px;
            flex-shrink: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .toast-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .toast-title {
            font-weight: 600;
            font-size: 14px;
            color: #333;
            line-height: 1.3;
        }

        .toast-message {
            font-size: 13px;
            color: #666;
            line-height: 1.4;
        }

        .toast-close {
            background: none;
            border: none;
            color: #999;
            cursor: pointer;
            font-size: 18px;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        .toast-close:hover {
            background: rgba(0, 0, 0, 0.1);
            color: #666;
        }

        /* Toast Types */
        .toast.success {
            border-left-color: #4caf50;
        }

        .toast.success .toast-icon {
            color: #4caf50;
        }

        .toast.success::before {
            background: linear-gradient(90deg, #4caf50, #66bb6a);
        }

        .toast.error {
            border-left-color: #f44336;
        }

        .toast.error .toast-icon {
            color: #f44336;
        }

        .toast.error::before {
            background: linear-gradient(90deg, #f44336, #ef5350);
        }

        .toast.warning {
            border-left-color: #ff9800;
        }

        .toast.warning .toast-icon {
            color: #ff9800;
        }

        .toast.warning::before {
            background: linear-gradient(90deg, #ff9800, #ffb74d);
        }

        .toast.info {
            border-left-color: #2196f3;
        }

        .toast.info .toast-icon {
            color: #2196f3;
        }

        .toast.info::before {
            background: linear-gradient(90deg, #2196f3, #42a5f5);
        }

        @media (max-width: 768px) {
            .main-container {
                flex-direction: column;
                padding: 1rem;
            }
            
            .sidebar {
                width: 100%;
                order: 2;
                max-height: none;
            }
            
            .tree-types {
                grid-template-columns: repeat(2, 1fr);
            }

            .header {
                padding: 1rem;
            }

            .header h1 {
                font-size: 1.4rem;
            }

            .company-logo {
                height: 45px;
            }

            .toast-container {
                bottom: 10px;
                right: 10px;
                left: 10px;
                max-width: none;
            }

            .toast {
                min-width: auto;
                max-width: none;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="logo-section">
            <img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRo8-Vr5qw1QlEE9lM2RnEei0Sr3k0fpod9Bw&s" alt="Logo de la Empresa" class="company-logo">
            <div class="header-text">
                <h1>Sistema de Planeaci√≥n de Reforestaciones</h1>
                <div class="subtitle">Herramienta profesional para dise√±o de proyectos ambientales</div>
            </div>
        </div>
    </div>

    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>

    <div class="main-container">
        <div class="sidebar">
            <!-- Carga de Imagen -->
            <div class="section">
                <h3>üì∏ Imagen Satelital</h3>
                <div class="file-input">
                    <label for="imageInput">Subir Imagen</label>
                    <input type="file" id="imageInput" accept="image/*">
                </div>
                <div id="imageInfo" style="display:none;">
                    <p><strong>Imagen cargada:</strong> <span id="imageName"></span></p>
                    <div class="controls">
                        <button class="btn btn-secondary" onclick="clearImage()">Limpiar</button>
                    </div>
                </div>
            </div>

            <!-- Escalado -->
            <div class="section">
                <h3>üìè Escalado Manual</h3>
                <button id="scaleBtn" class="btn" onclick="startScaling()">Definir Escala</button>
                <div id="scaleInfo" style="display:none; margin-top:0.5rem;">
                    <div class="input-group">
                        <label for="realLength">Longitud real (metros):</label>
                        <input type="number" id="realLength" placeholder="Ej: 5" step="0.1">
                        <button class="btn" onclick="setScale()">Confirmar Escala</button>
                    </div>
                </div>
                <div id="scaleResult" style="display:none; margin-top:0.5rem;">
                    <div class="alert alert-success">
                        <strong>Escala:</strong> <span id="scaleValue"></span>
                    </div>
                </div>
            </div>

            <!-- Delimitaci√≥n -->
            <div class="section">
                <h3>üó∫Ô∏è Delimitar Predio</h3>
                <div class="controls">
                    <button id="polygonBtn" class="btn" onclick="startPolygon()">Dibujar √Årea</button>
                    <button class="btn btn-danger" onclick="clearPolygon()">Limpiar</button>
                </div>
                <div id="polygonInfo" style="display:none; margin-top:0.5rem;">
                    <div class="alert alert-success">
                        <strong>√Årea:</strong> <span id="polygonArea"></span> m¬≤
                    </div>
                </div>
            </div>

            <!-- L√≠neas Gu√≠a -->
            <div class="section">
                <h3>üìê L√≠neas Gu√≠a</h3>
                <div class="tree-category-section">
                    <div class="tree-category-title">üìè Herramientas de Alineaci√≥n</div>
                    <div class="controls" style="margin-bottom: 1rem;">
                        <button class="btn" onclick="startGuidelineMode('line')" style="background: linear-gradient(135deg, #9c27b0 0%, #ba68c8 100%);">üìè L√≠nea</button>
                        <button class="btn" onclick="toggleSnapToGuides()" id="snapToggleBtn">üß≤ Snap ON</button>
                        <button class="btn" onclick="toggleGuidelineMeasurements()" id="measureToggleBtn">üìê Medidas ON</button>
                        <button class="btn" onclick="toggleGuidelinesVisibility()">üëÅÔ∏è Mostrar/Ocultar</button>
                        <button class="btn btn-danger" onclick="clearGuidelines()">üóëÔ∏è Limpiar</button>
                    </div>
                </div>
            </div>
            <!-- Tuber√≠as -->
            <div class="section">
                <h3>üîß Infraestructura - Tuber√≠as</h3>
                <div class="tree-category-section">
                    <div class="tree-category-title">üö∞ Tipos de Infraestructura</div>
                    <div class="controls" style="margin-bottom: 1rem;">
                        <button id="gasLineBtn" class="btn" onclick="startDrawingPipeline('gas')" style="background: linear-gradient(135deg, #ffc107 0%, #ffeb3b 100%);">‚õΩ Tuber√≠a Gas</button>
                        <button id="waterLineBtn" class="btn" onclick="startDrawingPipeline('agua')" style="background: linear-gradient(135deg, #2196f3 0%, #42a5f5 100%);">üíß Tuber√≠a Agua</button>
                        <button id="electricLineBtn" class="btn" onclick="startDrawingPipeline('electrica')" style="background: linear-gradient(135deg, #ff5722 0%, #ff7043 100%);">‚ö° Red El√©ctrica</button>
                        <button class="btn" onclick="clearPipelines()">üóëÔ∏è Limpiar Todo</button>
                    </div>
                    <div id="pipelineInfo" style="display:none; margin-top:0.5rem;">
                        <div class="alert alert-success">
                            <strong>Infraestructura mapeada:</strong> <span id="pipelineCount">0</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Tipos de √Årboles -->
            <div class="section">
                <h3>üå≤ Tipos de √Årboles</h3>
                
                <!-- √Årboles Nuevos -->
                <div class="tree-category-section">
                    <div class="tree-category-title collapsed" onclick="toggleTreeCategory('nuevos')" id="nuevos-header">
                        <span>üå± √Årboles Nuevos</span>
                        <span class="dropdown-arrow" id="nuevos-arrow">‚ñº</span>
                    </div>
                    <div class="tree-types-container" id="nuevos-content">
                        <div class="tree-types">
                            <div class="tree-item" draggable="true" data-type="NUEVO_3M" data-category="nuevo">
                                <div class="tree-icon tree-nuevo">üå±</div>
                                <div class="tree-name">Nuevo 3m</div>
                                <div class="tree-size">Di√°metro: 3m</div>
                            </div>
                            <div class="tree-item" draggable="true" data-type="NUEVO_4M" data-category="nuevo">
                                <div class="tree-icon tree-nuevo">üåø</div>
                                <div class="tree-name">Nuevo 4m</div>
                                <div class="tree-size">Di√°metro: 4m</div>
                            </div>
                            <div class="tree-item" draggable="true" data-type="NUEVO_5M" data-category="nuevo">
                                <div class="tree-icon tree-nuevo">üå≤</div>
                                <div class="tree-name">Nuevo 5m</div>
                                <div class="tree-size">Di√°metro: 5m</div>
                            </div>
                            <div class="tree-item" draggable="true" data-type="NUEVO_6M" data-category="nuevo">
                                <div class="tree-icon tree-nuevo">üå≥</div>
                                <div class="tree-name">Nuevo 6m</div>
                                <div class="tree-size">Di√°metro: 6m</div>
                            </div>
                            <div class="tree-item" draggable="true" data-type="NUEVO_7M" data-category="nuevo">
                                <div class="tree-icon tree-nuevo">üå¥</div>
                                <div class="tree-name">Nuevo 7m</div>
                                <div class="tree-size">Di√°metro: 7m</div>
                            </div>
                            <div class="tree-item" draggable="true" data-type="NUEVO_8M" data-category="nuevo">
                                <div class="tree-icon tree-nuevo">üå≤</div>
                                <div class="tree-name">Nuevo 8m</div>
                                <div class="tree-size">Di√°metro: 8m</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- √Årboles Existentes -->
                <div class="tree-category-section">
                    <div class="tree-category-title collapsed" onclick="toggleTreeCategory('existentes')" id="existentes-header">
                        <span>üå≥ √Årboles Existentes</span>
                        <span class="dropdown-arrow" id="existentes-arrow">‚ñº</span>
                    </div>
                    <div class="tree-types-container" id="existentes-content">
                        <div class="tree-types">
                            <div class="tree-item" draggable="true" data-type="EXISTENTE_1M" data-category="existente">
                                <div class="tree-icon tree-existente">üåø</div>
                                <div class="tree-name">Exist. 1m</div>
                                <div class="tree-size tree-size-small">Di√°metro: 1m</div>
                            </div>
                            <div class="tree-item" draggable="true" data-type="EXISTENTE_2M" data-category="existente">
                                <div class="tree-icon tree-existente">üå±</div>
                                <div class="tree-name">Exist. 2m</div>
                                <div class="tree-size tree-size-small">Di√°metro: 2m</div>
                            </div>
                            <div class="tree-item" draggable="true" data-type="EXISTENTE_3M" data-category="existente">
                                <div class="tree-icon tree-existente">üå≤</div>
                                <div class="tree-name">Exist. 3m</div>
                                <div class="tree-size tree-size-small">Di√°metro: 3m</div>
                            </div>
                            <div class="tree-item" draggable="true" data-type="EXISTENTE_4M" data-category="existente">
                                <div class="tree-icon tree-existente">üå≥</div>
                                <div class="tree-name">Exist. 4m</div>
                                <div class="tree-size tree-size-small">Di√°metro: 4m</div>
                            </div>
                            <div class="tree-item" draggable="true" data-type="EXISTENTE_5M" data-category="existente">
                                <div class="tree-icon tree-existente">üå¥</div>
                                <div class="tree-name">Exist. 5m</div>
                                <div class="tree-size tree-size-small">Di√°metro: 5m</div>
                            </div>
                            <div class="tree-item" draggable="true" data-type="EXISTENTE_6M" data-category="existente">
                                <div class="tree-icon tree-existente">üå≤</div>
                                <div class="tree-name">Exist. 6m</div>
                                <div class="tree-size tree-size-small">Di√°metro: 6m</div>
                            </div>
                            <div class="tree-item" draggable="true" data-type="EXISTENTE_7M" data-category="existente">
                                <div class="tree-icon tree-existente">üå≥</div>
                                <div class="tree-name">Exist. 7m</div>
                                <div class="tree-size tree-size-small">Di√°metro: 7m</div>
                            </div>
                            <div class="tree-item" draggable="true" data-type="EXISTENTE_8M" data-category="existente">
                                <div class="tree-icon tree-existente">üå¥</div>
                                <div class="tree-name">Exist. 8m</div>
                                <div class="tree-size tree-size-small">Di√°metro: 8m</div>
                            </div>
                            <div class="tree-item" draggable="true" data-type="EXISTENTE_9M" data-category="existente">
                                <div class="tree-icon tree-existente">üå≤</div>
                                <div class="tree-name">Exist. 9m</div>
                                <div class="tree-size tree-size-small">Di√°metro: 9m</div>
                            </div>
                            <div class="tree-item" draggable="true" data-type="EXISTENTE_10M" data-category="existente">
                                <div class="tree-icon tree-existente">üå≥</div>
                                <div class="tree-name">Exist. 10m</div>
                                <div class="tree-size tree-size-small">Di√°metro: 10m</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Capas Visuales -->
            <div class="section">
                <h3>üëÅÔ∏è Capas Visuales</h3>
                <div class="toggle-container">
                    <label class="toggle">
                        <input type="checkbox" id="showGrowthCircles" checked onchange="toggleLayer('growthCircles')">
                        <span class="slider"></span>
                    </label>
                    <span class="toggle-label">C√≠rculos de crecimiento</span>
                </div>
                <div class="toggle-container">
                    <label class="toggle">
                        <input type="checkbox" id="showTreeLabels" checked onchange="toggleLayer('treeLabels')">
                        <span class="slider"></span>
                    </label>
                    <span class="toggle-label">Nombres de √°rboles</span>
                </div>
                <div class="toggle-container">
                    <label class="toggle">
                        <input type="checkbox" id="showPolygon" checked onchange="toggleLayer('polygon')">
                        <span class="slider"></span>
                    </label>
                    <span class="toggle-label">L√≠mites del predio</span>
                </div>
                <div class="toggle-container">
                    <label class="toggle">
                        <input type="checkbox" id="showPipelines" checked onchange="toggleLayer('pipelines')">
                        <span class="slider"></span>
                    </label>
                    <span class="toggle-label">Tuber√≠as</span>
                </div>
                <div class="toggle-container">
                    <label class="toggle">
                        <input type="checkbox" id="showLegend" checked onchange="toggleLayerLegend()">
                        <span class="slider"></span>
                    </label>
                    <span class="toggle-label">Mostrar leyenda</span>
                </div>
            </div>

            <!-- Acciones -->
            <div class="section">
                <h3>‚ö° Acciones</h3>
                <div class="controls">
                    <button class="btn" onclick="generateReport()">üìä Reporte</button>
                    <button class="btn" onclick="exportReportToPNG()">üìÑ Exportar Reporte</button>
                    <button class="btn" onclick="exportProject()">üíæ Guardar</button>
                    <button class="btn" onclick="loadProject()">üìÇ Cargar</button>
                    <button class="btn" onclick="exportToPNG()">üì∏ Exportar Imagen</button>
                    <button class="btn" onclick="exportLegendToPNG()">üé® Exportar Leyenda</button>
                    <button class="btn btn-danger" onclick="clearAll()">üóëÔ∏è Limpiar Todo</button>
                </div>
            </div>
        </div>

        <div class="workspace">
            <div class="workspace-header">
                <div class="project-name-container">
                    <span>üó∫Ô∏è</span>
                    <span id="projectNameDisplay" class="project-name-display" onclick="editProjectName()" title="Clic para editar nombre del proyecto">
                        Proyecto de Reforestaci√≥n
                    </span>
                    <input type="text" id="projectNameInput" class="project-name-input" style="display: none;" 
                           placeholder="Nombre del proyecto" maxlength="50">
                    <button id="editProjectBtn" class="edit-project-btn" onclick="editProjectName()" title="Editar nombre del proyecto">
                        ‚úèÔ∏è
                    </button>
                    <button id="saveProjectBtn" class="save-project-btn" onclick="saveProjectName()" style="display: none;" title="Guardar nombre">
                        ‚úì
                    </button>
                </div>
                <div class="controls">
                    <button class="btn" onclick="zoomIn()" title="Acercar">üîç+</button>
                    <button class="btn" onclick="zoomOut()" title="Alejar">üîç-</button>
                    <button class="btn" onclick="resetZoom()" title="Restablecer Vista">üîÑ</button>
                    <button class="btn" onclick="exportToPNG()" title="Exportar Imagen">üì∏</button>
                    <button class="btn" onclick="exportLegendToPNG()" title="Exportar Leyenda">üé®</button>
                </div>
            </div>
            <div class="canvas-container" id="canvasContainer">
                <canvas id="mainCanvas" class="main-canvas"></canvas>
                
                <!-- Bot√≥n toggle de leyenda -->
                <button class="legend-toggle" id="legendToggle" onclick="toggleLegend()" title="Mostrar/Ocultar Leyenda">?</button>
                
                <!-- Leyenda de Colores -->
                <div class="legend collapsed" id="colorLegend">
                    <!-- Contenido generado din√°micamente -->
                </div>
            </div>
            <div class="status-bar">
                <span id="statusText">Listo para comenzar</span>
                <span id="treeCount">√Årboles: 0</span>
            </div>
        </div>
    </div>

    <!-- Modal para Reporte -->
    <div id="reportModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('reportModal')">&times;</span>
            <h2>üìä Reporte de Reforestaci√≥n</h2>
            <div id="reportContent"></div>
            <div style="margin-top: 1rem; text-align: center;">
                <button class="btn" onclick="closeModal('reportModal')">Cerrar</button>
            </div>
        </div>
    </div>

    <!-- Input oculto para cargar proyecto -->
    <input type="file" id="projectInput" accept=".json" style="display:none;">

    <script>
        // Variables globales
        let canvas, ctx;
        let backgroundImage = null;
        let scale = null; // metros por p√≠xel
        let scaleLine = null;
        let polygon = [];
        let trees = [];
        let pipelines = []; // Nueva variable para tuber√≠as
        let currentPipeline = null; // Tuber√≠a actual en construcci√≥n
        let selectedTree = null;
        let selectedPipeline = null; // Variable para tuber√≠a seleccionada
        let currentMode = 'normal'; // normal, scaling, polygon, pipeline
        let pipelineType = 'gas'; // gas, agua o electrica
        let zoom = 1;
        let panX = 0, panY = 0;
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };
        let dragStartPosition = null; // Para tracking de movimiento de √°rboles
        let dragStartPipelinePositions = null; // Para tracking de movimiento de tuber√≠as

        // Variables para preview de l√≠neas
        let previewLine = null; // Para mostrar l√≠neas en tiempo real

        // ================================
        // SISTEMA DE L√çNEAS GU√çA
        // ================================
        
        let guidelines = [];
        let currentGuideline = null;
        let guidelineMode = 'normal'; // normal, line, triangle, square
        let snapToGuides = true; // Por defecto activado
        let showGuidelineMeasurements = true; // Mostrar medidas en l√≠neas gu√≠a
        const SNAP_DISTANCE = 25; // Distancia en p√≠xeles para snap (aumentada)

        // Tipos de l√≠neas gu√≠a
        const GUIDELINE_TYPES = {
            LINE: 'line',
            TRIANGLE: 'triangle',
            SQUARE: 'square'
        };

        function startGuidelineMode(type) {
            if (!backgroundImage) {
                toastManager.warning('Imagen Requerida', 'Primero carga una imagen satelital');
                return;
            }
            
            guidelineMode = type;
            currentGuideline = {
                type: type,
                points: [],
                id: Date.now() + Math.random(),
                visible: true
            };
            
            canvas.style.cursor = 'crosshair';
            
            const typeNames = {
                line: 'l√≠nea gu√≠a',
                triangle: 'tri√°ngulo equil√°tero',
                square: 'cuadrado gu√≠a'
            };
            
            updateStatus(`Modo ${typeNames[type]} - Haz clic para crear puntos`);
            toastManager.info('L√≠neas Gu√≠a', `Dibujando ${typeNames[type]}. Haz clic para agregar puntos.`);
        }

        function finishGuideline() {
            if (!currentGuideline) return;
            
            let isValid = false;
            
            switch (currentGuideline.type) {
                case GUIDELINE_TYPES.LINE:
                    if (currentGuideline.points.length >= 2) {
                        isValid = true;
                    }
                    break;
                case GUIDELINE_TYPES.TRIANGLE:
                case GUIDELINE_TYPES.SQUARE:
                    if (currentGuideline.points.length >= 2) {
                        // Completar formas geom√©tricas autom√°ticamente
                        completeGeometricShape();
                        isValid = true;
                    }
                    break;
            }
            
            if (isValid) {
                // Guardar estado para undo antes de agregar l√≠nea gu√≠a
                saveUndoState(ACTION_TYPES.ADD_GUIDELINE, { guideline: JSON.parse(JSON.stringify(currentGuideline)) });
                
                guidelines.push(currentGuideline);
                toastManager.success('L√≠nea Gu√≠a Creada', 'L√≠nea gu√≠a agregada al proyecto');
            } else {
                toastManager.error('L√≠nea Incompleta', 'Se necesitan al menos 2 puntos');
            }
            
            currentGuideline = null;
            previewLine = null; // Limpiar preview
            guidelineMode = 'normal';
            canvas.style.cursor = 'grab';
            render();
            updateStatus('L√≠nea gu√≠a completada');
        }

        function completeGeometricShape() {
            if (!currentGuideline || currentGuideline.points.length < 2) return;
            
            const p1 = currentGuideline.points[0];
            const p2 = currentGuideline.points[1];
            
            if (currentGuideline.type === GUIDELINE_TYPES.TRIANGLE) {
                // Crear tri√°ngulo equil√°tero
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const length = Math.sqrt(dx * dx + dy * dy);
                
                // Calcular el tercer punto para formar un tri√°ngulo equil√°tero
                const angle = Math.atan2(dy, dx);
                const height = length * Math.sqrt(3) / 2;
                
                const p3 = {
                    x: p1.x + (dx / 2) - height * Math.sin(angle),
                    y: p1.y + (dy / 2) + height * Math.cos(angle)
                };
                
                currentGuideline.points = [p1, p2, p3, p1]; // Cerrar el tri√°ngulo
                
            } else if (currentGuideline.type === GUIDELINE_TYPES.SQUARE) {
                // Crear cuadrado
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                
                // Calcular los otros dos puntos del cuadrado
                const p3 = {
                    x: p2.x - dy,
                    y: p2.y + dx
                };
                
                const p4 = {
                    x: p1.x - dy,
                    y: p1.y + dx
                };
                
                currentGuideline.points = [p1, p2, p3, p4, p1]; // Cerrar el cuadrado
            }
        }

        function clearGuidelines() {
            if (guidelines.length === 0 && !currentGuideline) {
                toastManager.warning('Sin L√≠neas Gu√≠a', 'No hay l√≠neas gu√≠a para limpiar');
                return;
            }
            
            // Guardar estado para undo antes de limpiar
            if (guidelines.length > 0) {
                saveUndoState(ACTION_TYPES.CLEAR_GUIDELINES, { guidelines: JSON.parse(JSON.stringify(guidelines)) });
            }
            
            guidelines = [];
            currentGuideline = null;
            
            if (guidelineMode !== 'normal') {
                guidelineMode = 'normal';
                canvas.style.cursor = 'grab';
            }
            
            render();
            updateStatus('L√≠neas gu√≠a eliminadas');
            toastManager.success('L√≠neas Gu√≠a Eliminadas', 'Todas las l√≠neas gu√≠a han sido eliminadas');
        }

        function toggleGuidelineMeasurements() {
            showGuidelineMeasurements = !showGuidelineMeasurements;
            
            // Actualizar visual del bot√≥n para feedback inmediato
            const measureButton = document.querySelector('button[onclick="toggleGuidelineMeasurements()"]');
            if (measureButton) {
                if (showGuidelineMeasurements) {
                    measureButton.style.background = 'linear-gradient(135deg, #4caf50 0%, #66bb6a 100%)';
                    measureButton.textContent = 'üìê Medidas ON';
                } else {
                    measureButton.style.background = 'linear-gradient(135deg, #81c784 0%, #a5d6a7 100%)';
                    measureButton.textContent = 'üìê Medidas OFF';
                }
            }
            
            // Re-renderizar para mostrar/ocultar medidas
            render();
            updateStatus(`Medidas en l√≠neas gu√≠a: ${showGuidelineMeasurements ? 'activadas' : 'desactivadas'}`);
            toastManager.info('Medidas de L√≠neas Gu√≠a', `Medidas ${showGuidelineMeasurements ? 'activadas' : 'desactivadas'}`);
        }

        function toggleSnapToGuides() {
            snapToGuides = !snapToGuides;
            
            // Actualizar visual del bot√≥n para feedback inmediato
            const snapButton = document.querySelector('button[onclick="toggleSnapToGuides()"]');
            if (snapButton) {
                if (snapToGuides) {
                    snapButton.style.background = 'linear-gradient(135deg, #4caf50 0%, #66bb6a 100%)';
                    snapButton.textContent = 'üß≤ Snap ON';
                } else {
                    snapButton.style.background = 'linear-gradient(135deg, #81c784 0%, #a5d6a7 100%)';
                    snapButton.textContent = 'üß≤ Snap OFF';
                }
            }
            
            updateStatus(`Snap a gu√≠as: ${snapToGuides ? 'activado' : 'desactivado'}`);
            toastManager.info('Snap a Gu√≠as', `Snap ${snapToGuides ? 'activado' : 'desactivado'}`);
        }

        function toggleGuidelinesVisibility() {
            const visible = !guidelines.every(g => g.visible);
            guidelines.forEach(g => g.visible = visible);
            render();
            updateStatus(`L√≠neas gu√≠a: ${visible ? 'visibles' : 'ocultas'}`);
        }

        function snapToGuidelines(x, y) {
            if (!snapToGuides || guidelines.length === 0) {
                return { x, y };
            }
            
            let closestPoint = { x, y };
            let minDistance = SNAP_DISTANCE / zoom; // Ajustar por zoom
            
            guidelines.forEach(guideline => {
                if (!guideline.visible) return;
                
                // Snap a puntos espec√≠ficos de la l√≠nea gu√≠a
                guideline.points.forEach(point => {
                    const distance = Math.sqrt(
                        Math.pow(x - point.x, 2) + Math.pow(y - point.y, 2)
                    );
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestPoint = { x: point.x, y: point.y };
                    }
                });
                
                // Snap a cualquier punto a lo largo de las l√≠neas
                for (let i = 0; i < guideline.points.length - 1; i++) {
                    const p1 = guideline.points[i];
                    const p2 = guideline.points[i + 1];
                    
                    // Encontrar el punto m√°s cercano en la l√≠nea
                    const snapPoint = getClosestPointOnLine(x, y, p1.x, p1.y, p2.x, p2.y);
                    const distance = Math.sqrt(
                        Math.pow(x - snapPoint.x, 2) + Math.pow(y - snapPoint.y, 2)
                    );
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestPoint = snapPoint;
                    }
                }
            });
            
            return closestPoint;
        }

        function getClosestPointOnLine(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            
            if (lenSq === 0) return { x: x1, y: y1 };
            
            let t = Math.max(0, Math.min(1, dot / lenSq));
            
            return {
                x: x1 + t * C,
                y: y1 + t * D
            };
        }

        function drawGuidelines() {
            // Dibujar l√≠neas gu√≠a terminadas
            guidelines.forEach(guideline => {
                if (!guideline.visible || guideline.points.length < 2) return;
                
                ctx.strokeStyle = '#9c27b0'; // Morado
                ctx.lineWidth = 2 / zoom;
                ctx.setLineDash([10 / zoom, 5 / zoom]);
                ctx.globalAlpha = 0.7;
                
                ctx.beginPath();
                ctx.moveTo(guideline.points[0].x, guideline.points[0].y);
                
                for (let i = 1; i < guideline.points.length; i++) {
                    ctx.lineTo(guideline.points[i].x, guideline.points[i].y);
                }
                
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.globalAlpha = 1;
                
                // Dibujar puntos de intersecci√≥n
                ctx.fillStyle = '#9c27b0'; // Morado
                guideline.points.forEach(point => {
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 3 / zoom, 0, 2 * Math.PI);
                    ctx.fill();
                });
                
                // Mostrar medidas en segmentos terminados si est√° activado
                if (showGuidelineMeasurements && scale) {
                    ctx.globalAlpha = 0.9;
                    ctx.font = `bold ${12 / zoom}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    for (let i = 0; i < guideline.points.length - 1; i++) {
                        const p1 = guideline.points[i];
                        const p2 = guideline.points[i + 1];
                        
                        const pixelLength = Math.sqrt(
                            Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2)
                        );
                        const realLength = pixelLength * scale;
                        
                        // Calcular punto medio del segmento
                        const midX = (p1.x + p2.x) / 2;
                        const midY = (p1.y + p2.y) / 2;
                        
                        // Texto de medida
                        const text = `${realLength.toFixed(1)}m`;
                        const textWidth = ctx.measureText(text).width;
                        const padding = 3 / zoom;
                        
                        // Fondo semitransparente para el texto
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                        ctx.fillRect(
                            midX - textWidth/2 - padding, 
                            midY - 6/zoom - padding, 
                            textWidth + padding*2, 
                            12/zoom + padding*2
                        );
                        
                        // Dibujar texto
                        ctx.fillStyle = '#9c27b0'; // Morado
                        ctx.fillText(text, midX, midY);
                    }
                    
                    ctx.globalAlpha = 1;
                }
            });
            
            // Dibujar l√≠nea gu√≠a en construcci√≥n
            if (currentGuideline && currentGuideline.points.length > 0) {
                ctx.strokeStyle = '#9c27b0'; // Morado
                ctx.lineWidth = 2 / zoom;
                ctx.setLineDash([5 / zoom, 5 / zoom]);
                ctx.globalAlpha = 0.9;
                
                ctx.beginPath();
                ctx.moveTo(currentGuideline.points[0].x, currentGuideline.points[0].y);
                
                for (let i = 1; i < currentGuideline.points.length; i++) {
                    ctx.lineTo(currentGuideline.points[i].x, currentGuideline.points[i].y);
                }
                
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Mostrar medidas en segmentos ya confirmados durante construcci√≥n
                if (showGuidelineMeasurements && scale && currentGuideline.points.length > 1) {
                    ctx.font = `bold ${12 / zoom}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    for (let i = 0; i < currentGuideline.points.length - 1; i++) {
                        const p1 = currentGuideline.points[i];
                        const p2 = currentGuideline.points[i + 1];
                        
                        const pixelLength = Math.sqrt(
                            Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2)
                        );
                        const realLength = pixelLength * scale;
                        
                        // Calcular punto medio del segmento
                        const midX = (p1.x + p2.x) / 2;
                        const midY = (p1.y + p2.y) / 2;
                        
                        // Texto de medida
                        const text = `${realLength.toFixed(1)}m`;
                        const textWidth = ctx.measureText(text).width;
                        const padding = 3 / zoom;
                        
                        // Fondo semitransparente para el texto
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                        ctx.fillRect(
                            midX - textWidth/2 - padding, 
                            midY - 6/zoom - padding, 
                            textWidth + padding*2, 
                            12/zoom + padding*2
                        );
                        
                        // Dibujar texto
                        ctx.fillStyle = '#9c27b0'; // Morado
                        ctx.fillText(text, midX, midY);
                    }
                }
                
                ctx.globalAlpha = 1;
                
                // Dibujar puntos
                ctx.fillStyle = '#9c27b0'; // Morado
                currentGuideline.points.forEach(point => {
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 3 / zoom, 0, 2 * Math.PI);
                    ctx.fill();
                });
            }
        }
        let projectName = 'Proyecto de Reforestaci√≥n'; // Variable para el nombre del proyecto

        // ================================
        // SISTEMA DE UNDO/REDO (CTRL+Z)
        // ================================
        
        let undoStack = [];
        let redoStack = [];
        const MAX_UNDO_STEPS = 50;

        // Tipos de acciones para el historial
        const ACTION_TYPES = {
            ADD_TREE: 'add_tree',
            DELETE_TREE: 'delete_tree',
            MOVE_TREE: 'move_tree',
            ADD_PIPELINE: 'add_pipeline',
            DELETE_PIPELINE: 'delete_pipeline',
            MOVE_PIPELINE: 'move_pipeline',
            ADD_GUIDELINE: 'add_guideline',
            DELETE_GUIDELINE: 'delete_guideline',
            CLEAR_GUIDELINES: 'clear_guidelines'
        };

        function saveUndoState(actionType, data) {
            // Limpiar redo stack cuando se hace una nueva acci√≥n
            redoStack = [];
            
            // Crear snapshot del estado actual
            const undoData = {
                actionType: actionType,
                timestamp: Date.now(),
                trees: JSON.parse(JSON.stringify(trees)),
                pipelines: JSON.parse(JSON.stringify(pipelines)),
                guidelines: JSON.parse(JSON.stringify(guidelines)),
                actionData: data
            };
            
            undoStack.push(undoData);
            
            // Limitar el tama√±o del stack
            if (undoStack.length > MAX_UNDO_STEPS) {
                undoStack.shift();
            }
        }

        function undo() {
            if (undoStack.length === 0) {
                toastManager.warning('Sin Acciones', 'No hay acciones para deshacer');
                return;
            }
            
            // Guardar estado actual en redo stack antes de hacer undo
            const currentState = {
                actionType: 'current_state',
                trees: JSON.parse(JSON.stringify(trees)),
                pipelines: JSON.parse(JSON.stringify(pipelines)),
                guidelines: JSON.parse(JSON.stringify(guidelines))
            };
            redoStack.push(currentState);
            
            // Obtener la acci√≥n a deshacer
            const undoData = undoStack.pop();
            
            // Aplicar la acci√≥n de undo seg√∫n el tipo
            switch (undoData.actionType) {
                case ACTION_TYPES.ADD_TREE:
                    // Remover el √∫ltimo √°rbol agregado
                    trees.pop();
                    break;
                    
                case ACTION_TYPES.DELETE_TREE:
                    // Restaurar el √°rbol eliminado
                    const deletedTreeData = undoData.actionData;
                    trees.splice(deletedTreeData.index, 0, deletedTreeData.tree);
                    break;
                    
                case ACTION_TYPES.MOVE_TREE:
                    // Restaurar posici√≥n anterior del √°rbol
                    const moveTreeData = undoData.actionData;
                    const treeToMove = trees.find(t => t.id === moveTreeData.treeId);
                    if (treeToMove) {
                        treeToMove.x = moveTreeData.oldPosition.x;
                        treeToMove.y = moveTreeData.oldPosition.y;
                    }
                    break;
                    
                case ACTION_TYPES.ADD_PIPELINE:
                    // Remover la √∫ltima tuber√≠a agregada
                    pipelines.pop();
                    break;
                    
                case ACTION_TYPES.DELETE_PIPELINE:
                    // Restaurar la tuber√≠a eliminada
                    const deletedPipelineData = undoData.actionData;
                    pipelines.splice(deletedPipelineData.index, 0, deletedPipelineData.pipeline);
                    break;
                    
                case ACTION_TYPES.MOVE_PIPELINE:
                    // Restaurar posici√≥n anterior de la tuber√≠a
                    const movePipelineData = undoData.actionData;
                    const pipelineToMove = pipelines[movePipelineData.pipelineIndex];
                    if (pipelineToMove) {
                        pipelineToMove.points = movePipelineData.oldPositions.map(pos => ({ x: pos.x, y: pos.y }));
                    }
                    break;
                    
                case ACTION_TYPES.ADD_GUIDELINE:
                    // Remover la √∫ltima l√≠nea gu√≠a agregada
                    guidelines.pop();
                    break;
                    
                case ACTION_TYPES.DELETE_GUIDELINE:
                    // Restaurar la l√≠nea gu√≠a eliminada
                    const deletedGuidelineData = undoData.actionData;
                    guidelines.splice(deletedGuidelineData.index, 0, deletedGuidelineData.guideline);
                    break;
                    
                case ACTION_TYPES.CLEAR_GUIDELINES:
                    // Restaurar todas las l√≠neas gu√≠a
                    guidelines = undoData.actionData.guidelines;
                    break;
                    
                default:
                    // Fallback: restaurar estado completo
                    trees = undoData.trees;
                    pipelines = undoData.pipelines;
                    guidelines = undoData.guidelines;
                    break;
            }
            
            // Limpiar selecciones
            selectedTree = null;
            selectedPipeline = null;
            
            // Actualizar UI
            updateTreeCount();
            updatePipelineInfo();
            render();
            
            // Actualizar leyenda si est√° visible
            const legend = document.getElementById('colorLegend');
            if (legend && !legend.classList.contains('collapsed')) {
                updateDynamicLegend();
            }
            
            updateStatus('Acci√≥n deshecha');
        }

        function redo() {
            if (redoStack.length === 0) {
                toastManager.warning('Sin Acciones', 'No hay acciones para rehacer');
                return;
            }
            
            // Obtener estado a restaurar
            const redoData = redoStack.pop();
            
            // Guardar estado actual en undo stack
            saveUndoState('redo_action', null);
            
            // Restaurar estado
            trees = redoData.trees;
            pipelines = redoData.pipelines;
            guidelines = redoData.guidelines;
            
            // Limpiar selecciones
            selectedTree = null;
            selectedPipeline = null;
            
            // Actualizar UI
            updateTreeCount();
            updatePipelineInfo();
            render();
            
            // Actualizar leyenda si est√° visible
            const legend = document.getElementById('colorLegend');
            if (legend && !legend.classList.contains('collapsed')) {
                updateDynamicLegend();
            }
            
            updateStatus('Acci√≥n rehecha');
        }

        // ================================
        // TOAST NOTIFICATION SYSTEM
        // ================================

        class ToastManager {
            constructor() {
                this.container = document.getElementById('toastContainer');
                this.toasts = new Map();
                this.counter = 0;
            }

            show(type, title, message, duration = 5000) {
                const toastId = ++this.counter;
                const toast = this.createToast(toastId, type, title, message, duration);
                
                this.container.appendChild(toast);
                this.toasts.set(toastId, toast);

                // Trigger animation
                requestAnimationFrame(() => {
                    toast.classList.add('show');
                });

                // Auto remove
                if (duration > 0) {
                    setTimeout(() => {
                        this.hide(toastId);
                    }, duration);
                }

                return toastId;
            }

            createToast(id, type, title, message, duration) {
                const toast = document.createElement('div');
                toast.className = `toast ${type}`;
                toast.dataset.toastId = id;

                const icons = {
                    success: '‚úÖ',
                    error: '‚ùå',
                    warning: '‚ö†Ô∏è',
                    info: '‚ÑπÔ∏è'
                };

                toast.innerHTML = `
                    <div class="toast-icon">${icons[type] || icons.info}</div>
                    <div class="toast-content">
                        <div class="toast-title">${title}</div>
                        ${message ? `<div class="toast-message">${message}</div>` : ''}
                    </div>
                    <button class="toast-close" onclick="toastManager.hide(${id})">&times;</button>
                `;

                // Pause/resume animation on hover
                toast.addEventListener('mouseenter', () => {
                    toast.classList.add('paused');
                });

                toast.addEventListener('mouseleave', () => {
                    toast.classList.remove('paused');
                });

                // Click to dismiss
                toast.addEventListener('click', (e) => {
                    if (!e.target.classList.contains('toast-close')) {
                        this.hide(id);
                    }
                });

                return toast;
            }

            hide(toastId) {
                const toast = this.toasts.get(toastId);
                if (!toast) return;

                toast.classList.add('hide');
                
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                    this.toasts.delete(toastId);
                }, 400);
            }

            // Convenience methods
            success(title, message, duration) {
                return this.show('success', title, message, duration);
            }

            error(title, message, duration = 7000) {
                return this.show('error', title, message, duration);
            }

            warning(title, message, duration = 6000) {
                return this.show('warning', title, message, duration);
            }

            info(title, message, duration) {
                return this.show('info', title, message, duration);
            }

            // Clear all toasts
            clear() {
                this.toasts.forEach((toast, id) => {
                    this.hide(id);
                });
            }
        }

        // Initialize toast manager
        const toastManager = new ToastManager();

        // Configuraciones expandidas de √°rboles
        const treeConfig = {
            // √Årboles Nuevos (3-8 metros) - TODOS VERDES
            'NUEVO_3M': { name: 'Nuevo 3m', category: 'nuevo', diameter: 3, color: '#4caf50', icon: 'üå±' },
            'NUEVO_4M': { name: 'Nuevo 4m', category: 'nuevo', diameter: 4, color: '#4caf50', icon: 'üåø' },
            'NUEVO_5M': { name: 'Nuevo 5m', category: 'nuevo', diameter: 5, color: '#4caf50', icon: 'üå≤' },
            'NUEVO_6M': { name: 'Nuevo 6m', category: 'nuevo', diameter: 6, color: '#4caf50', icon: 'üå≥' },
            'NUEVO_7M': { name: 'Nuevo 7m', category: 'nuevo', diameter: 7, color: '#4caf50', icon: 'üå¥' },
            'NUEVO_8M': { name: 'Nuevo 8m', category: 'nuevo', diameter: 8, color: '#4caf50', icon: 'üå≤' },
            
            // √Årboles Existentes (1-10 metros) - TODOS AZULES
            'EXISTENTE_1M': { name: 'Exist. 1m', category: 'existente', diameter: 1, color: '#2196f3', icon: 'üåø' },
            'EXISTENTE_2M': { name: 'Exist. 2m', category: 'existente', diameter: 2, color: '#2196f3', icon: 'üå±' },
            'EXISTENTE_3M': { name: 'Exist. 3m', category: 'existente', diameter: 3, color: '#2196f3', icon: 'üå≤' },
            'EXISTENTE_4M': { name: 'Exist. 4m', category: 'existente', diameter: 4, color: '#2196f3', icon: 'üå≥' },
            'EXISTENTE_5M': { name: 'Exist. 5m', category: 'existente', diameter: 5, color: '#2196f3', icon: 'üå¥' },
            'EXISTENTE_6M': { name: 'Exist. 6m', category: 'existente', diameter: 6, color: '#2196f3', icon: 'üå≤' },
            'EXISTENTE_7M': { name: 'Exist. 7m', category: 'existente', diameter: 7, color: '#2196f3', icon: 'üå≥' },
            'EXISTENTE_8M': { name: 'Exist. 8m', category: 'existente', diameter: 8, color: '#2196f3', icon: 'üå¥' },
            'EXISTENTE_9M': { name: 'Exist. 9m', category: 'existente', diameter: 9, color: '#2196f3', icon: 'üå≤' },
            'EXISTENTE_10M': { name: 'Exist. 10m', category: 'existente', diameter: 10, color: '#2196f3', icon: 'üå≥' }
        };

        // Configuraciones de capas
        let layerVisibility = {
            growthCircles: true,
            treeLabels: true,
            polygon: true,
            pipelines: true
        };

        // Inicializaci√≥n
        document.addEventListener('DOMContentLoaded', function() {
            canvas = document.getElementById('mainCanvas');
            if (!canvas) {
                toastManager.error('Error del Sistema', 'No se pudo inicializar el canvas');
                return;
            }
            
            ctx = canvas.getContext('2d');
            if (!ctx) {
                toastManager.error('Error del Sistema', 'No se pudo obtener el contexto 2D del canvas');
                return;
            }
            
            setupCanvas();
            setupEventListeners();
            
            toastManager.success('Sistema Iniciado', 'Bienvenido al Sistema de Planeaci√≥n de Reforestaciones', 3000);
            updateStatus('Sistema iniciado - Carga una imagen para comenzar');
        });

        function setupCanvas() {
            const container = document.getElementById('canvasContainer');
            if (!container || !canvas) {
                toastManager.error('Error de Configuraci√≥n', 'No se pudo configurar el √°rea de trabajo');
                return;
            }
            
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            
            // Eventos del canvas con verificaci√≥n
            if (canvas) {
                canvas.addEventListener('click', handleCanvasClick);
                canvas.addEventListener('mousedown', handleMouseDown);
                canvas.addEventListener('mousemove', handleMouseMove);
                canvas.addEventListener('mouseup', handleMouseUp);
                canvas.addEventListener('dragover', handleDragOver);
                canvas.addEventListener('drop', handleDrop);
                canvas.addEventListener('wheel', handleWheel);
            }
            
            render();
        }

        function setupEventListeners() {
            // Carga de imagen
            const imageInput = document.getElementById('imageInput');
            if (imageInput) {
                imageInput.addEventListener('change', loadImage);
            }
            
            // Drag and drop de √°rboles - Solo para elementos visibles inicialmente
            setupTreeDragAndDrop();
            
            // Redimensionar canvas
            window.addEventListener('resize', debounce(() => {
                const container = document.getElementById('canvasContainer');
                if (!container || !canvas) return;
                
                const oldWidth = canvas.width;
                const oldHeight = canvas.height;
                
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                
                // Ajustar pan proporcionalmente
                if (oldWidth > 0 && oldHeight > 0) {
                    panX = (panX / oldWidth) * canvas.width;
                    panY = (panY / oldHeight) * canvas.height;
                }
                
                render();
            }, 250));
            
            // Cargar proyecto
            const projectInput = document.getElementById('projectInput');
            if (projectInput) {
                projectInput.addEventListener('change', handleProjectLoad);
            }
        }

        function setupTreeDragAndDrop() {
            // Configurar eventos de drag and drop para todas las categor√≠as
            const allTreeItems = document.querySelectorAll('.tree-item');
            allTreeItems.forEach(item => {
                if (item) {
                    item.addEventListener('dragstart', handleTreeDragStart);
                }
            });
        }

        // Funciones de utilidad
        function updateStatus(message) {
            const statusElement = document.getElementById('statusText');
            if (statusElement) {
                statusElement.textContent = message;
            }
        }

        // Funci√≥n de debounce para mejorar performance
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        function loadImage(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            // Validar tipo de archivo
            if (!file.type.startsWith('image/')) {
                toastManager.error('Archivo Inv√°lido', 'Por favor selecciona un archivo de imagen v√°lido (JPG, PNG, etc.)');
                return;
            }
            
            toastManager.info('Cargando Imagen', 'Procesando archivo de imagen...', 2000);
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    backgroundImage = img;
                    
                    // Centrar y ajustar imagen en el canvas
                    centerAndFitImage();
                    
                    // Mostrar informaci√≥n de la imagen
                    document.getElementById('imageName').textContent = file.name;
                    document.getElementById('imageInfo').style.display = 'block';
                    
                    render();
                    updateStatus('Imagen cargada - Define la escala para comenzar');
                    
                    toastManager.success('Imagen Cargada', `${file.name} se carg√≥ correctamente. Ahora define la escala.`);
                };
                img.onerror = function() {
                    toastManager.error('Error de Imagen', 'No se pudo cargar la imagen. Verifica que el archivo no est√© da√±ado.');
                };
                img.src = e.target.result;
            };
            reader.onerror = function() {
                toastManager.error('Error de Lectura', 'No se pudo leer el archivo seleccionado');
            };
            reader.readAsDataURL(file);
        }

        function centerAndFitImage() {
            if (!backgroundImage) return;
            
            const containerWidth = canvas.width;
            const containerHeight = canvas.height;
            const imgWidth = backgroundImage.width;
            const imgHeight = backgroundImage.height;
            
            // Calcular zoom para que la imagen se ajuste al canvas
            const scaleX = containerWidth / imgWidth;
            const scaleY = containerHeight / imgHeight;
            zoom = Math.min(scaleX, scaleY) * 0.9; // 0.9 para dejar un margen
            
            // Centrar la imagen
            const scaledWidth = imgWidth * zoom;
            const scaledHeight = imgHeight * zoom;
            panX = (containerWidth - scaledWidth) / 2;
            panY = (containerHeight - scaledHeight) / 2;
        }

        function clearImage() {
            if (!backgroundImage) {
                toastManager.warning('Sin Imagen', 'No hay ninguna imagen para limpiar');
                return;
            }

            backgroundImage = null;
            scale = null;
            polygon = [];
            trees = [];
            pipelines = [];
            currentPipeline = null;
            zoom = 1;
            panX = 0;
            panY = 0;
            selectedTree = null;
            currentMode = 'normal';
            
            // Limpiar input de archivo
            const imageInput = document.getElementById('imageInput');
            if (imageInput) {
                imageInput.value = '';
            }
            
            // Ocultar elementos de UI con verificaci√≥n
            const elementsToHide = ['imageInfo', 'scaleResult', 'polygonInfo', 'scaleInfo', 'pipelineInfo'];
            elementsToHide.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.style.display = 'none';
                }
            });
            
            updateTreeCount();
            updatePipelineInfo();
            render();
            updateStatus('Imagen eliminada - Sistema listo');
            
            toastManager.success('Imagen Eliminada', 'La imagen y todos los datos han sido limpiados');
        }

        // Funciones de escalado
        function startScaling() {
            if (!backgroundImage) {
                toastManager.warning('Imagen Requerida', 'Primero carga una imagen satelital');
                return;
            }
            
            currentMode = 'scaling';
            scaleLine = null;
            document.getElementById('scaleInfo').style.display = 'block';
            canvas.style.cursor = 'crosshair';
            updateStatus('Modo escalado - Haz clic y arrastra para definir una l√≠nea de referencia');
            toastManager.info('Modo Escalado', 'Dibuja una l√≠nea sobre una distancia conocida en la imagen');
        }

        function setScale() {
            const realLength = parseFloat(document.getElementById('realLength').value);
            
            if (!scaleLine || !realLength || realLength <= 0) {
                toastManager.error('Datos Incompletos', 'Dibuja una l√≠nea de referencia e ingresa la longitud real');
                return;
            }
            
            const pixelLength = Math.sqrt(
                Math.pow(scaleLine.end.x - scaleLine.start.x, 2) + 
                Math.pow(scaleLine.end.y - scaleLine.start.y, 2)
            );
            
            if (pixelLength < 10) {
                toastManager.error('L√≠nea Muy Corta', 'Dibuja una l√≠nea m√°s larga para mayor precisi√≥n');
                return;
            }
            
            scale = realLength / pixelLength; // metros por p√≠xel
            
            // Mostrar resultado
            document.getElementById('scaleValue').textContent = `1 p√≠xel = ${scale.toFixed(4)} metros`;
            document.getElementById('scaleResult').style.display = 'block';
            document.getElementById('scaleInfo').style.display = 'none';
            
            // Resetear modo
            currentMode = 'normal';
            scaleLine = null;
            canvas.style.cursor = 'grab';
            
            render();
            updateStatus('Escala definida - Ahora puedes delimitar el √°rea y colocar √°rboles');
            toastManager.success('Escala Definida', `Escala establecida: 1 p√≠xel = ${scale.toFixed(4)} metros`);
        }

        // Funciones de pol√≠gono
        function startPolygon() {
            if (!backgroundImage) {
                toastManager.warning('Imagen Requerida', 'Primero carga una imagen satelital');
                return;
            }
            
            currentMode = 'polygon';
            polygon = [];
            canvas.style.cursor = 'crosshair';
            updateStatus('Modo delimitaci√≥n - Haz clic para crear puntos, doble clic para terminar');
            toastManager.info('Modo Delimitaci√≥n', 'Haz clic para agregar puntos del per√≠metro. Doble clic para finalizar.');
        }

        function finishPolygon() {
            if (polygon.length < 3) {
                toastManager.error('Pol√≠gono Incompleto', 'Se necesitan al menos 3 puntos para crear un √°rea');
                return;
            }
            
            currentMode = 'normal';
            canvas.style.cursor = 'grab';
            
            if (scale) {
                const area = calculatePolygonArea(polygon, scale);
                document.getElementById('polygonArea').textContent = area.toLocaleString('es-ES');
                document.getElementById('polygonInfo').style.display = 'block';
                toastManager.success('√Årea Delimitada', `√Årea calculada: ${area.toLocaleString('es-ES')} m¬≤`);
            } else {
                toastManager.warning('Escala No Definida', 'Define la escala para calcular el √°rea en metros');
            }
            
            render();
            updateStatus('√Årea delimitada - Ahora puedes colocar √°rboles');
        }

        function clearPolygon() {
            if (polygon.length === 0) {
                toastManager.warning('Sin √Årea', 'No hay ning√∫n √°rea para limpiar');
                return;
            }
            
            polygon = [];
            document.getElementById('polygonInfo').style.display = 'none';
            
            if (currentMode === 'polygon') {
                currentMode = 'normal';
                canvas.style.cursor = 'grab';
            }
            
            render();
            updateStatus('√Årea eliminada');
            toastManager.success('√Årea Eliminada', 'El per√≠metro ha sido eliminado');
        }

        function calculatePolygonArea(points, pixelScale) {
            if (points.length < 3) return 0;
            
            let area = 0;
            for (let i = 0; i < points.length; i++) {
                const j = (i + 1) % points.length;
                area += points[i].x * points[j].y;
                area -= points[j].x * points[i].y;
            }
            
            const pixelArea = Math.abs(area) / 2;
            return Math.round(pixelArea * pixelScale * pixelScale); // Convertir a metros cuadrados
        }

        // Funciones de tuber√≠as
        function startDrawingPipeline(type) {
            if (!backgroundImage) {
                toastManager.warning('Imagen Requerida', 'Primero carga una imagen satelital');
                return;
            }
            
            currentMode = 'pipeline';
            pipelineType = type;
            currentPipeline = {
                type: type,
                points: [],
                name: `${type.charAt(0).toUpperCase() + type.slice(1)} ${pipelines.filter(p => p.type === type).length + 1}`
            };
            
            canvas.style.cursor = 'crosshair';
            
            const typeNames = {
                'gas': 'tuber√≠a de gas',
                'agua': 'tuber√≠a de agua',
                'electrica': 'red el√©ctrica'
            };
            
            updateStatus(`Modo ${typeNames[type]} - Haz clic para crear puntos, doble clic para terminar`);
            toastManager.info('Modo Infraestructura', `Dibujando ${typeNames[type]}. Haz clic para agregar puntos.`);
        }

        function finishPipeline() {
            if (!currentPipeline || currentPipeline.points.length < 2) {
                toastManager.error('Tuber√≠a Incompleta', 'Se necesitan al menos 2 puntos para crear una tuber√≠a');
                return;
            }
            
            // Guardar estado para undo antes de hacer cambios
            saveUndoState(ACTION_TYPES.ADD_PIPELINE, { pipeline: JSON.parse(JSON.stringify(currentPipeline)) });
            
            pipelines.push(currentPipeline);
            currentPipeline = null;
            previewLine = null; // Limpiar preview
            currentMode = 'normal';
            canvas.style.cursor = 'grab';
            
            updatePipelineInfo();
            render();
            updateStatus('Tuber√≠a completada');
            toastManager.success('Infraestructura Agregada', 'Tuber√≠a completada exitosamente');
        }

        function clearPipelines() {
            if (pipelines.length === 0 && !currentPipeline) {
                toastManager.warning('Sin Infraestructura', 'No hay tuber√≠as para limpiar');
                return;
            }
            
            pipelines = [];
            currentPipeline = null;
            selectedPipeline = null;
            
            if (currentMode === 'pipeline') {
                currentMode = 'normal';
                canvas.style.cursor = 'grab';
            }
            
            updatePipelineInfo();
            render();
            updateStatus('Tuber√≠as eliminadas');
            toastManager.success('Infraestructura Eliminada', 'Todas las tuber√≠as han sido eliminadas');
        }

        function updatePipelineInfo() {
            const pipelineInfo = document.getElementById('pipelineInfo');
            const pipelineCount = document.getElementById('pipelineCount');
            
            if (pipelines.length > 0) {
                pipelineCount.textContent = pipelines.length;
                pipelineInfo.style.display = 'block';
            } else {
                pipelineInfo.style.display = 'none';
            }
        }

        // Funciones de manejo de eventos del canvas
        function getCanvasCoordinates(event) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (event.clientX - rect.left - panX) / zoom,
                y: (event.clientY - rect.top - panY) / zoom
            };
        }

        function handleCanvasClick(event) {
            const coords = getCanvasCoordinates(event);
            
            if (currentMode === 'polygon') {
                polygon.push(coords);
                
                if (event.detail === 2 && polygon.length >= 3) { // Doble clic
                    finishPolygon();
                }
                render();
            } else if (currentMode === 'pipeline') {
                currentPipeline.points.push(coords);
                
                // Limpiar preview despu√©s de agregar punto
                previewLine = null;
                
                if (event.detail === 2 && currentPipeline.points.length >= 2) { // Doble clic
                    finishPipeline();
                }
                render();
            } else if (guidelineMode !== 'normal') {
                // Modo l√≠neas gu√≠a
                if (event.detail === 2 && currentGuideline.points.length >= 2) { // Doble clic
                    // No agregar el punto del doble clic, solo finalizar
                    finishGuideline();
                } else {
                    // Click simple - agregar punto
                    currentGuideline.points.push(coords);
                    
                    // Limpiar preview despu√©s de agregar punto
                    previewLine = null;
                    render();
                }
            } else if (currentMode === 'normal') {
                const clickedTree = getTreeAt(coords.x, coords.y);
                const clickedPipeline = getPipelineAt(coords.x, coords.y);
                
                if (clickedTree) {
                    selectedTree = clickedTree;
                    selectedPipeline = null;
                } else if (clickedPipeline) {
                    selectedPipeline = clickedPipeline;
                    selectedTree = null;
                } else {
                    selectedTree = null;
                    selectedPipeline = null;
                }
                render();
            }
        }

        function handleMouseDown(event) {
            const coords = getCanvasCoordinates(event);
            
            if (currentMode === 'scaling' && !scaleLine) {
                scaleLine = { start: coords, end: coords };
                isDragging = true;
            } else if (currentMode === 'normal') {
                const tree = getTreeAt(coords.x, coords.y);
                const pipeline = getPipelineAt(coords.x, coords.y);
                
                if (tree) {
                    selectedTree = tree;
                    selectedPipeline = null;
                    isDragging = true;
                    dragStart = { x: event.clientX, y: event.clientY };
                    
                    // Guardar posici√≥n inicial para undo si se mueve
                    dragStartPosition = { x: tree.x, y: tree.y };
                } else if (pipeline) {
                    selectedPipeline = pipeline;
                    selectedTree = null;
                    isDragging = true;
                    dragStart = { 
                        x: event.clientX, 
                        y: event.clientY,
                        worldX: coords.x,
                        worldY: coords.y
                    };
                    
                    // Guardar posici√≥n inicial para undo si se mueve
                    dragStartPipelinePositions = pipeline.points.map(point => ({ x: point.x, y: point.y }));
                } else {
                    selectedTree = null;
                    selectedPipeline = null;
                    isDragging = true;
                    dragStart = { x: event.clientX - panX, y: event.clientY - panY };
                    canvas.style.cursor = 'grabbing';
                }
            }
        }

        function handleMouseMove(event) {
            if (!isDragging) {
                // Manejar preview de l√≠neas cuando no se est√° arrastrando
                const coords = getCanvasCoordinates(event);
                
                if (currentMode === 'pipeline' && currentPipeline && currentPipeline.points.length > 0) {
                    // Preview para tuber√≠a en construcci√≥n
                    const lastPoint = currentPipeline.points[currentPipeline.points.length - 1];
                    previewLine = {
                        type: 'pipeline',
                        pipelineType: currentPipeline.type,
                        start: lastPoint,
                        end: coords
                    };
                    render();
                } else if (guidelineMode !== 'normal' && currentGuideline && currentGuideline.points.length > 0) {
                    // Preview para l√≠nea gu√≠a en construcci√≥n
                    const lastPoint = currentGuideline.points[currentGuideline.points.length - 1];
                    previewLine = {
                        type: 'guideline',
                        start: lastPoint,
                        end: coords
                    };
                    render();
                } else {
                    // Limpiar preview si no estamos en modo de dibujo
                    if (previewLine) {
                        previewLine = null;
                        render();
                    }
                }
                return;
            }
            
            const coords = getCanvasCoordinates(event);
            
            if (currentMode === 'scaling' && scaleLine) {
                scaleLine.end = coords;
                render();
            } else if (currentMode === 'normal' && selectedTree) {
                // Aplicar snap al mover √°rboles tambi√©n
                const snappedCoords = snapToGuidelines(coords.x, coords.y);
                selectedTree.x = snappedCoords.x;
                selectedTree.y = snappedCoords.y;
                render();
            } else if (currentMode === 'normal' && selectedPipeline) {
                const deltaX = (event.clientX - dragStart.x) / zoom;
                const deltaY = (event.clientY - dragStart.y) / zoom;
                
                selectedPipeline.points.forEach(point => {
                    point.x += deltaX;
                    point.y += deltaY;
                });
                
                dragStart.x = event.clientX;
                dragStart.y = event.clientY;
                render();
            } else if (currentMode === 'normal' && !selectedTree && !selectedPipeline) {
                panX = event.clientX - dragStart.x;
                panY = event.clientY - dragStart.y;
                render();
            }
        }

        function handleMouseUp(event) {
            if (isDragging && selectedTree && dragStartPosition) {
                // Verificar si el √°rbol se movi√≥ significativamente
                const deltaX = Math.abs(selectedTree.x - dragStartPosition.x);
                const deltaY = Math.abs(selectedTree.y - dragStartPosition.y);
                
                if (deltaX > 1 || deltaY > 1) { // Umbral m√≠nimo para considerar movimiento
                    // Guardar estado para undo despu√©s del movimiento
                    saveUndoState(ACTION_TYPES.MOVE_TREE, {
                        treeId: selectedTree.id,
                        oldPosition: dragStartPosition,
                        newPosition: { x: selectedTree.x, y: selectedTree.y }
                    });
                }
                dragStartPosition = null;
            } else if (isDragging && selectedPipeline && dragStartPipelinePositions) {
                // Verificar si la tuber√≠a se movi√≥
                let moved = false;
                for (let i = 0; i < selectedPipeline.points.length; i++) {
                    const oldPos = dragStartPipelinePositions[i];
                    const newPos = selectedPipeline.points[i];
                    if (Math.abs(newPos.x - oldPos.x) > 1 || Math.abs(newPos.y - oldPos.y) > 1) {
                        moved = true;
                        break;
                    }
                }
                
                if (moved) {
                    saveUndoState(ACTION_TYPES.MOVE_PIPELINE, {
                        pipelineIndex: pipelines.indexOf(selectedPipeline),
                        oldPositions: dragStartPipelinePositions,
                        newPositions: selectedPipeline.points.map(p => ({ x: p.x, y: p.y }))
                    });
                }
                dragStartPipelinePositions = null;
            }
            
            isDragging = false;
            canvas.style.cursor = currentMode === 'normal' ? 'grab' : 'crosshair';
        }

        function handleDragOver(event) {
            event.preventDefault();
        }

        function handleDrop(event) {
            event.preventDefault();
            
            const treeType = event.dataTransfer.getData('text/plain');
            if (!treeType || !backgroundImage) {
                if (!backgroundImage) {
                    toastManager.warning('Imagen Requerida', 'Primero carga una imagen satelital');
                }
                return;
            }
            
            const coords = getCanvasCoordinates(event);
            
            // Aplicar snap a l√≠neas gu√≠a si est√° activado
            const snappedCoords = snapToGuidelines(coords.x, coords.y);
            
            addTree(treeType, snappedCoords.x, snappedCoords.y);
        }

        function handleWheel(event) {
            event.preventDefault();
            
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            
            const zoomFactor = event.deltaY > 0 ? 0.9 : 1.1;
            const newZoom = Math.max(0.1, Math.min(5, zoom * zoomFactor));
            
            if (newZoom !== zoom) {
                const zoomChange = newZoom / zoom;
                panX = mouseX - (mouseX - panX) * zoomChange;
                panY = mouseY - (mouseY - panY) * zoomChange;
                zoom = newZoom;
                render();
            }
        }

        function handleTreeDragStart(event) {
            const treeType = event.target.closest('.tree-item').dataset.type;
            event.dataTransfer.setData('text/plain', treeType);
        }

        // Funciones de √°rboles
        function addTree(type, x, y) {
            if (!treeConfig[type]) {
                toastManager.error('Tipo Inv√°lido', 'Tipo de √°rbol no reconocido');
                return;
            }
            
            // Guardar estado para undo antes de hacer cambios
            saveUndoState(ACTION_TYPES.ADD_TREE, { type, x, y });
            
            const tree = {
                id: Date.now() + Math.random(),
                type: type,
                config: treeConfig[type],
                x: x,
                y: y
            };
            
            trees.push(tree);
            updateTreeCount();
            render();
            
            // Actualizar leyenda si est√° visible
            const legend = document.getElementById('colorLegend');
            if (legend && !legend.classList.contains('collapsed')) {
                updateDynamicLegend();
            }
        }

        function getTreeAt(x, y) {
            for (let i = trees.length - 1; i >= 0; i--) {
                const tree = trees[i];
                const distance = Math.sqrt(Math.pow(x - tree.x, 2) + Math.pow(y - tree.y, 2));
                const radius = (tree.config.diameter * (scale ? 1/scale : 20)) / 2;
                
                if (distance <= radius) {
                    return tree;
                }
            }
            return null;
        }

        function getPipelineAt(x, y) {
            const tolerance = 10 / zoom;
            
            for (let pipeline of pipelines) {
                for (let i = 0; i < pipeline.points.length - 1; i++) {
                    const start = pipeline.points[i];
                    const end = pipeline.points[i + 1];
                    
                    const distance = distanceToLineSegment(x, y, start.x, start.y, end.x, end.y);
                    if (distance <= tolerance) {
                        return pipeline;
                    }
                }
            }
            return null;
        }

        function distanceToLineSegment(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            
            if (lenSq === 0) return Math.sqrt(A * A + B * B);
            
            let t = Math.max(0, Math.min(1, dot / lenSq));
            
            const projection = {
                x: x1 + t * C,
                y: y1 + t * D
            };
            
            return Math.sqrt(Math.pow(px - projection.x, 2) + Math.pow(py - projection.y, 2));
        }

        function updateTreeCount() {
            const count = trees.length;
            document.getElementById('treeCount').textContent = `√Årboles: ${count}`;
        }

        // Funciones de render
        function render() {
            if (!ctx) return;
            
            // Limpiar canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Aplicar transformaciones
            ctx.save();
            ctx.translate(panX, panY);
            ctx.scale(zoom, zoom);
            
            // Dibujar imagen de fondo
            if (backgroundImage) {
                ctx.drawImage(backgroundImage, 0, 0);
            }
            
            // Dibujar pol√≠gono
            if (layerVisibility.polygon && polygon.length > 0) {
                drawPolygon();
            }
            
            // Dibujar l√≠neas gu√≠a
            drawGuidelines();
            
            // Dibujar tuber√≠as
            if (layerVisibility.pipelines) {
                drawPipelines();
            }
            
            // Dibujar l√≠nea de escala
            if (scaleLine && currentMode === 'scaling') {
                drawScaleLine();
            }
            
            // Dibujar preview de l√≠nea
            if (previewLine) {
                drawPreviewLine();
            }
            
            // Dibujar √°rboles
            drawTrees();
            
            ctx.restore();
        }

        function drawPreviewLine() {
            if (!previewLine) return;
            
            ctx.save();
            
            if (previewLine.type === 'pipeline') {
                // Preview para tuber√≠a
                const pipelineStyles = {
                    gas: { color: '#ffc107', width: 4 },
                    agua: { color: '#2196f3', width: 4 },
                    electrica: { color: '#ff5722', width: 3 }
                };
                
                const style = pipelineStyles[previewLine.pipelineType];
                if (style) {
                    ctx.strokeStyle = style.color;
                    ctx.lineWidth = style.width / zoom;
                    ctx.globalAlpha = 0.6; // Semitransparente
                    ctx.setLineDash([10 / zoom, 5 / zoom]); // L√≠nea punteada
                    
                    ctx.beginPath();
                    ctx.moveTo(previewLine.start.x, previewLine.start.y);
                    ctx.lineTo(previewLine.end.x, previewLine.end.y);
                    ctx.stroke();
                }
            } else if (previewLine.type === 'guideline') {
                // Preview para l√≠nea gu√≠a
                ctx.strokeStyle = '#9c27b0'; // Morado
                ctx.lineWidth = 2 / zoom;
                ctx.globalAlpha = 0.6; // Semitransparente
                ctx.setLineDash([8 / zoom, 4 / zoom]); // L√≠nea punteada
                
                ctx.beginPath();
                ctx.moveTo(previewLine.start.x, previewLine.start.y);
                ctx.lineTo(previewLine.end.x, previewLine.end.y);
                ctx.stroke();
                
                // Mostrar distancia en tiempo real para l√≠neas gu√≠a
                if (scale && showGuidelineMeasurements) {
                    const pixelLength = Math.sqrt(
                        Math.pow(previewLine.end.x - previewLine.start.x, 2) + 
                        Math.pow(previewLine.end.y - previewLine.start.y, 2)
                    );
                    const realLength = pixelLength * scale;
                    
                    // Calcular punto medio para mostrar el texto
                    const midX = (previewLine.start.x + previewLine.end.x) / 2;
                    const midY = (previewLine.start.y + previewLine.end.y) / 2;
                    
                    // Configurar texto
                    ctx.globalAlpha = 0.9;
                    ctx.fillStyle = '#9c27b0'; // Morado
                    ctx.font = `bold ${14 / zoom}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // Fondo semitransparente para el texto
                    const text = `${realLength.toFixed(1)}m`;
                    const textWidth = ctx.measureText(text).width;
                    const padding = 4 / zoom;
                    
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.fillRect(
                        midX - textWidth/2 - padding, 
                        midY - 7/zoom - padding, 
                        textWidth + padding*2, 
                        14/zoom + padding*2
                    );
                    
                    // Dibujar texto
                    ctx.fillStyle = '#9c27b0'; // Morado
                    ctx.fillText(text, midX, midY);
                }
            }
            
            ctx.restore();
        }

        function drawPolygon() {
            if (polygon.length === 0) return;
            
            ctx.strokeStyle = '#007bff';
            ctx.fillStyle = 'rgba(0, 123, 255, 0.1)';
            ctx.lineWidth = 3 / zoom;
            
            ctx.beginPath();
            ctx.moveTo(polygon[0].x, polygon[0].y);
            
            for (let i = 1; i < polygon.length; i++) {
                ctx.lineTo(polygon[i].x, polygon[i].y);
            }
            
            if (currentMode !== 'polygon') {
                ctx.closePath();
                ctx.fill();
            }
            
            ctx.stroke();
            
            // Dibujar puntos
            ctx.fillStyle = '#007bff';
            for (let point of polygon) {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 4 / zoom, 0, 2 * Math.PI);
                ctx.fill();
            }
        }

        function drawPipelines() {
            const pipelineStyles = {
                gas: { color: '#ffc107', width: 4 },
                agua: { color: '#2196f3', width: 4 },
                electrica: { color: '#ff5722', width: 3 }
            };
            
            // Dibujar tuber√≠as terminadas
            pipelines.forEach(pipeline => {
                const style = pipelineStyles[pipeline.type];
                if (!style || pipeline.points.length < 2) return;
                
                ctx.strokeStyle = selectedPipeline === pipeline ? '#ff0000' : style.color;
                ctx.lineWidth = style.width / zoom;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                ctx.beginPath();
                ctx.moveTo(pipeline.points[0].x, pipeline.points[0].y);
                
                for (let i = 1; i < pipeline.points.length; i++) {
                    ctx.lineTo(pipeline.points[i].x, pipeline.points[i].y);
                }
                
                ctx.stroke();
                
                // Dibujar puntos de conexi√≥n
                ctx.fillStyle = style.color;
                pipeline.points.forEach(point => {
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 3 / zoom, 0, 2 * Math.PI);
                    ctx.fill();
                });
            });
            
            // Dibujar tuber√≠a en construcci√≥n
            if (currentPipeline && currentPipeline.points.length > 0) {
                const style = pipelineStyles[currentPipeline.type];
                if (style) {
                    ctx.strokeStyle = style.color;
                    ctx.lineWidth = style.width / zoom;
                    ctx.setLineDash([5 / zoom, 5 / zoom]);
                    
                    ctx.beginPath();
                    ctx.moveTo(currentPipeline.points[0].x, currentPipeline.points[0].y);
                    
                    for (let i = 1; i < currentPipeline.points.length; i++) {
                        ctx.lineTo(currentPipeline.points[i].x, currentPipeline.points[i].y);
                    }
                    
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Dibujar puntos
                    ctx.fillStyle = style.color;
                    currentPipeline.points.forEach(point => {
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, 3 / zoom, 0, 2 * Math.PI);
                        ctx.fill();
                    });
                }
            }
        }

        function drawScaleLine() {
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 3 / zoom;
            ctx.lineCap = 'round';
            
            ctx.beginPath();
            ctx.moveTo(scaleLine.start.x, scaleLine.start.y);
            ctx.lineTo(scaleLine.end.x, scaleLine.end.y);
            ctx.stroke();
            
            // Dibujar puntos de inicio y fin
            ctx.fillStyle = '#ff0000';
            
            ctx.beginPath();
            ctx.arc(scaleLine.start.x, scaleLine.start.y, 4 / zoom, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(scaleLine.end.x, scaleLine.end.y, 4 / zoom, 0, 2 * Math.PI);
            ctx.fill();
        }

        function drawTrees() {
            trees.forEach(tree => {
                const radius = scale ? (tree.config.diameter / 2) / scale : tree.config.diameter * 10;
                const isSelected = selectedTree === tree;
                
                // Definir colores m√°s oscuros para el punto central
                const centerColor = tree.config.category === 'nuevo' ? '#2e7d32' : '#1565c0'; // Verde oscuro y azul oscuro
                
                // Dibujar c√≠rculo de crecimiento
                if (layerVisibility.growthCircles) {
                    ctx.strokeStyle = isSelected ? '#ff0000' : tree.config.color;
                    ctx.lineWidth = isSelected ? 3 / zoom : 2 / zoom;
                    ctx.fillStyle = tree.config.color + '20';
                    
                    ctx.beginPath();
                    ctx.arc(tree.x, tree.y, radius, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                }
                
                // Dibujar centro del √°rbol con color m√°s oscuro
                ctx.fillStyle = isSelected ? '#ff0000' : centerColor;
                ctx.beginPath();
                ctx.arc(tree.x, tree.y, 4 / zoom, 0, 2 * Math.PI);
                ctx.fill();
                
                // Dibujar etiqueta con solo el tama√±o
                if (layerVisibility.treeLabels) {
                    ctx.fillStyle = '#000000';
                    ctx.font = `${12 / zoom}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.fillText(`${tree.config.diameter}m`, tree.x, tree.y - radius - 8 / zoom);
                }
            });
        }

        // Funciones de capas
        function toggleLayer(layerName) {
            layerVisibility[layerName] = !layerVisibility[layerName];
            render();
            
            // Actualizar leyenda si est√° visible
            const legend = document.getElementById('colorLegend');
            if (legend && !legend.classList.contains('collapsed')) {
                updateDynamicLegend();
            }
        }

        function toggleLayerLegend() {
            const showLegend = document.getElementById('showLegend').checked;
            const legend = document.getElementById('colorLegend');
            const toggle = document.getElementById('legendToggle');
            
            if (showLegend) {
                legend.classList.remove('collapsed');
                toggle.style.display = 'none';
                updateDynamicLegend();
            } else {
                legend.classList.add('collapsed');
                toggle.style.display = 'flex';
            }
        }

        // Funciones de zoom
        function zoomIn() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            const newZoom = Math.min(5, zoom * 1.2);
            const zoomChange = newZoom / zoom;
            
            panX = centerX - (centerX - panX) * zoomChange;
            panY = centerY - (centerY - panY) * zoomChange;
            zoom = newZoom;
            
            render();
        }

        function zoomOut() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            const newZoom = Math.max(0.1, zoom * 0.8);
            const zoomChange = newZoom / zoom;
            
            panX = centerX - (centerX - panX) * zoomChange;
            panY = centerY - (centerY - panY) * zoomChange;
            zoom = newZoom;
            
            render();
        }

        function resetZoom() {
            if (backgroundImage) {
                centerAndFitImage();
            } else {
                zoom = 1;
                panX = 0;
                panY = 0;
            }
            render();
        }

        // Funciones de proyecto
        function editProjectName() {
            const display = document.getElementById('projectNameDisplay');
            const input = document.getElementById('projectNameInput');
            const editBtn = document.getElementById('editProjectBtn');
            const saveBtn = document.getElementById('saveProjectBtn');
            
            display.style.display = 'none';
            input.style.display = 'inline-block';
            input.value = projectName;
            input.focus();
            input.select();
            editBtn.style.display = 'none';
            saveBtn.style.display = 'inline-block';
        }

        function saveProjectName() {
            const display = document.getElementById('projectNameDisplay');
            const input = document.getElementById('projectNameInput');
            const editBtn = document.getElementById('editProjectBtn');
            const saveBtn = document.getElementById('saveProjectBtn');
            
            const newName = input.value.trim();
            if (newName) {
                projectName = newName;
                display.textContent = projectName;
            }
            
            display.style.display = 'inline-block';
            input.style.display = 'none';
            editBtn.style.display = 'inline-block';
            saveBtn.style.display = 'none';
        }

        function cancelEditProjectName() {
            const display = document.getElementById('projectNameDisplay');
            const input = document.getElementById('projectNameInput');
            const editBtn = document.getElementById('editProjectBtn');
            const saveBtn = document.getElementById('saveProjectBtn');
            
            display.style.display = 'inline-block';
            input.style.display = 'none';
            editBtn.style.display = 'inline-block';
            saveBtn.style.display = 'none';
        }

        // Funci√≥n para cerrar leyenda manualmente
        function closeLegendManually() {
            const legend = document.getElementById('colorLegend');
            const toggle = document.getElementById('legendToggle');
            const showLegendCheckbox = document.getElementById('showLegend');
            
            // Ocultar leyenda
            legend.classList.add('collapsed');
            toggle.style.display = 'flex';
            
            // Actualizar checkbox
            showLegendCheckbox.checked = false;
        }

        // Funci√≥n para toggle de categor√≠as de √°rboles
        function toggleTreeCategory(category) {
            const header = document.getElementById(`${category}-header`);
            const content = document.getElementById(`${category}-content`);
            const arrow = document.getElementById(`${category}-arrow`);
            
            if (!header || !content || !arrow) return;
            
            const isExpanded = content.classList.contains('expanded');
            
            if (isExpanded) {
                // Colapsar
                content.classList.remove('expanded');
                header.classList.remove('expanded');
                header.classList.add('collapsed');
                arrow.classList.remove('expanded');
                
                // Re-configurar drag and drop para elementos ocultos
                setTimeout(() => {
                    const treeItems = content.querySelectorAll('.tree-item');
                    treeItems.forEach(item => {
                        item.removeEventListener('dragstart', handleTreeDragStart);
                    });
                }, 300);
            } else {
                // Expandir
                content.classList.add('expanded');
                header.classList.remove('collapsed');
                header.classList.add('expanded');
                arrow.classList.add('expanded');
                
                // Configurar drag and drop para elementos visibles
                setTimeout(() => {
                    const treeItems = content.querySelectorAll('.tree-item');
                    treeItems.forEach(item => {
                        item.addEventListener('dragstart', handleTreeDragStart);
                    });
                }, 50);
            }
        }

        function clearAll() {
            if (!backgroundImage && trees.length === 0 && pipelines.length === 0 && polygon.length === 0) {
                toastManager.warning('Sin Datos', 'No hay datos para limpiar');
                return;
            }
            
            if (confirm('¬øEst√°s seguro de que quieres limpiar todo el proyecto?')) {
                backgroundImage = null;
                scale = null;
                scaleLine = null;
                polygon = [];
                trees = [];
                pipelines = [];
                currentPipeline = null;
                selectedTree = null;
                selectedPipeline = null;
                currentMode = 'normal';
                zoom = 1;
                panX = 0;
                panY = 0;
                
                // Limpiar UI
                const imageInput = document.getElementById('imageInput');
                if (imageInput) imageInput.value = '';
                
                const elementsToHide = ['imageInfo', 'scaleResult', 'polygonInfo', 'scaleInfo', 'pipelineInfo'];
                elementsToHide.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) element.style.display = 'none';
                });
                
                updateTreeCount();
                render();
                updateStatus('Proyecto limpiado - Listo para comenzar');
                toastManager.success('Proyecto Limpiado', 'Todos los datos han sido eliminados');
            }
        }

        // Funciones de exportaci√≥n e importaci√≥n
        function exportProject() {
            // Convertir imagen de fondo a base64 si existe
            let backgroundImageData = null;
            if (backgroundImage) {
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = backgroundImage.width;
                tempCanvas.height = backgroundImage.height;
                tempCtx.drawImage(backgroundImage, 0, 0);
                backgroundImageData = tempCanvas.toDataURL('image/png');
            }
            
            const projectData = {
                version: '1.0',
                name: projectName,
                scale: scale,
                polygon: polygon,
                trees: trees,
                pipelines: pipelines,
                layerVisibility: layerVisibility,
                zoom: zoom,
                panX: panX,
                panY: panY,
                backgroundImageData: backgroundImageData, // Incluir imagen en base64
                timestamp: new Date().toISOString()
            };
            
            const blob = new Blob([JSON.stringify(projectData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${projectName}_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            toastManager.success('Proyecto Exportado', `${projectName} guardado con imagen de fondo incluida`);
        }

        function loadProject() {
            const projectInput = document.getElementById('projectInput');
            if (projectInput) {
                projectInput.click();
            }
        }

        function handleProjectLoad(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!file.name.endsWith('.json')) {
                toastManager.error('Archivo Inv√°lido', 'Por favor selecciona un archivo JSON v√°lido');
                return;
            }
            
            toastManager.info('Cargando Proyecto', 'Procesando archivo del proyecto...', 3000);
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const projectData = JSON.parse(e.target.result);
                    
                    // Validar estructura b√°sica
                    if (!projectData.version || !projectData.name) {
                        throw new Error('Formato de proyecto inv√°lido');
                    }
                    
                    // Cargar imagen de fondo si existe
                    if (projectData.backgroundImageData) {
                        const img = new Image();
                        img.onload = function() {
                            backgroundImage = img;
                            loadProjectData(projectData);
                            toastManager.success('Proyecto Cargado', `${projectName} cargado con imagen de fondo`);
                        };
                        img.onerror = function() {
                            toastManager.warning('Imagen No Cargada', 'El proyecto se carg√≥ pero la imagen de fondo fall√≥');
                            loadProjectData(projectData);
                        };
                        img.src = projectData.backgroundImageData;
                    } else {
                        // Cargar proyecto sin imagen de fondo
                        backgroundImage = null;
                        loadProjectData(projectData);
                        toastManager.success('Proyecto Cargado', `${projectName} cargado correctamente (sin imagen de fondo)`);
                    }
                    
                } catch (error) {
                    toastManager.error('Error de Carga', 'No se pudo cargar el proyecto. Verifica que el archivo sea v√°lido.');
                    console.error('Error loading project:', error);
                }
            };
            
            reader.onerror = function() {
                toastManager.error('Error de Lectura', 'No se pudo leer el archivo del proyecto');
            };
            
            reader.readAsText(file);
        }

        function loadProjectData(projectData) {
            // Cargar datos del proyecto
            projectName = projectData.name || 'Proyecto Cargado';
            scale = projectData.scale || null;
            polygon = projectData.polygon || [];
            trees = projectData.trees || [];
            pipelines = projectData.pipelines || [];
            layerVisibility = { ...layerVisibility, ...projectData.layerVisibility };
            zoom = projectData.zoom || 1;
            panX = projectData.panX || 0;
            panY = projectData.panY || 0;
            
            // Actualizar UI
            document.getElementById('projectNameDisplay').textContent = projectName;
            
            // Actualizar informaci√≥n de imagen si se carg√≥
            if (backgroundImage) {
                document.getElementById('imageName').textContent = 'Imagen del proyecto';
                document.getElementById('imageInfo').style.display = 'block';
            } else {
                document.getElementById('imageInfo').style.display = 'none';
                // Limpiar input de archivo
                const imageInput = document.getElementById('imageInput');
                if (imageInput) {
                    imageInput.value = '';
                }
            }
            
            // Actualizar checkboxes de capas
            Object.keys(layerVisibility).forEach(layer => {
                const checkbox = document.getElementById(`show${layer.charAt(0).toUpperCase() + layer.slice(1)}`);
                if (checkbox) {
                    checkbox.checked = layerVisibility[layer];
                }
            });
            
            // Actualizar informaci√≥n de proyecto
            if (scale) {
                document.getElementById('scaleValue').textContent = `1 p√≠xel = ${scale.toFixed(4)} metros`;
                document.getElementById('scaleResult').style.display = 'block';
            } else {
                document.getElementById('scaleResult').style.display = 'none';
            }
            
            if (polygon.length > 0 && scale) {
                const area = calculatePolygonArea(polygon, scale);
                document.getElementById('polygonArea').textContent = area.toLocaleString('en-US');
                document.getElementById('polygonInfo').style.display = 'block';
            } else {
                document.getElementById('polygonInfo').style.display = 'none';
            }
            
            updateTreeCount();
            updatePipelineInfo();
            render();
            
            // Actualizar leyenda si est√° visible
            const legend = document.getElementById('colorLegend');
            if (legend && !legend.classList.contains('collapsed')) {
                updateDynamicLegend();
            }
            
            updateStatus('Proyecto cargado exitosamente');
        }

        // Funciones de exportaci√≥n de im√°genes
        function exportToPNG() {
            if (!backgroundImage && trees.length === 0 && pipelines.length === 0 && polygon.length === 0) {
                toastManager.warning('Sin Contenido', 'No hay contenido para exportar');
                return;
            }
            
            // Crear un canvas temporal para la exportaci√≥n
            const exportCanvas = document.createElement('canvas');
            const exportCtx = exportCanvas.getContext('2d');
            
            // Determinar dimensiones basadas en el contenido
            let bounds = getContentBounds();
            if (!bounds && backgroundImage) {
                bounds = {
                    minX: 0,
                    minY: 0,
                    maxX: backgroundImage.width,
                    maxY: backgroundImage.height
                };
            }
            
            if (!bounds) {
                toastManager.error('Sin Contenido', 'No se pudo determinar el √°rea a exportar');
                return;
            }
            
            const margin = 50;
            exportCanvas.width = (bounds.maxX - bounds.minX) + margin * 2;
            exportCanvas.height = (bounds.maxY - bounds.minY) + margin * 2;
            
            // Configurar contexto de exportaci√≥n
            exportCtx.fillStyle = '#ffffff';
            exportCtx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
            
            exportCtx.translate(margin - bounds.minX, margin - bounds.minY);
            
            // Dibujar contenido
            if (backgroundImage) {
                exportCtx.drawImage(backgroundImage, 0, 0);
            }
            
            // Dibujar elementos (sin transformaciones de zoom/pan)
            const originalZoom = zoom;
            const originalPanX = panX;
            const originalPanY = panY;
            
            zoom = 1;
            panX = 0;
            panY = 0;
            
            // Cambiar el contexto temporalmente
            const originalCtx = ctx;
            ctx = exportCtx;
            
            if (layerVisibility.polygon && polygon.length > 0) {
                drawPolygon();
            }
            
            if (layerVisibility.pipelines) {
                drawPipelines();
            }
            
            drawTrees();
            
            // Restaurar contexto y configuraciones
            ctx = originalCtx;
            zoom = originalZoom;
            panX = originalPanX;
            panY = originalPanY;
            
            // Descargar imagen
            exportCanvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${projectName}_${new Date().toISOString().split('T')[0]}.png`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                toastManager.success('Imagen Exportada', 'El mapa se export√≥ como imagen PNG');
            });
        }

        function getContentBounds() {
            let bounds = null;
            
            // Incluir √°rboles
            trees.forEach(tree => {
                const radius = scale ? (tree.config.diameter / 2) / scale : tree.config.diameter * 10;
                const treeBounds = {
                    minX: tree.x - radius,
                    minY: tree.y - radius,
                    maxX: tree.x + radius,
                    maxY: tree.y + radius
                };
                
                if (!bounds) {
                    bounds = treeBounds;
                } else {
                    bounds.minX = Math.min(bounds.minX, treeBounds.minX);
                    bounds.minY = Math.min(bounds.minY, treeBounds.minY);
                    bounds.maxX = Math.max(bounds.maxX, treeBounds.maxX);
                    bounds.maxY = Math.max(bounds.maxY, treeBounds.maxY);
                }
            });
            
            // Incluir pol√≠gono
            polygon.forEach(point => {
                if (!bounds) {
                    bounds = { minX: point.x, minY: point.y, maxX: point.x, maxY: point.y };
                } else {
                    bounds.minX = Math.min(bounds.minX, point.x);
                    bounds.minY = Math.min(bounds.minY, point.y);
                    bounds.maxX = Math.max(bounds.maxX, point.x);
                    bounds.maxY = Math.max(bounds.maxY, point.y);
                }
            });
            
            // Incluir tuber√≠as
            pipelines.forEach(pipeline => {
                pipeline.points.forEach(point => {
                    if (!bounds) {
                        bounds = { minX: point.x, minY: point.y, maxX: point.x, maxY: point.y };
                    } else {
                        bounds.minX = Math.min(bounds.minX, point.x);
                        bounds.minY = Math.min(bounds.minY, point.y);
                        bounds.maxX = Math.max(bounds.maxX, point.x);
                        bounds.maxY = Math.max(bounds.maxY, point.y);
                    }
                });
            });
            
            return bounds;
        }

        // Funciones de leyenda
        function toggleLegend() {
            const legend = document.getElementById('colorLegend');
            const toggle = document.getElementById('legendToggle');
            const showLegendCheckbox = document.getElementById('showLegend');
            
            if (legend.classList.contains('collapsed')) {
                legend.classList.remove('collapsed');
                toggle.style.display = 'none';
                showLegendCheckbox.checked = true;
                updateDynamicLegend();
            } else {
                legend.classList.add('collapsed');
                toggle.style.display = 'flex';
                showLegendCheckbox.checked = false;
            }
        }

        function updateDynamicLegend() {
            const legend = document.getElementById('colorLegend');
            if (!legend || legend.classList.contains('collapsed')) return;
            
            // Obtener tipos √∫nicos de √°rboles presentes
            const uniqueTreeTypes = [...new Set(trees.map(tree => tree.type))];
            
            // Obtener tipos √∫nicos de tuber√≠as presentes
            const uniquePipelineTypes = [...new Set(pipelines.map(p => p.type))];
            
            let legendHTML = '<h4>Leyenda del Proyecto<button class="legend-close-btn" onclick="closeLegendManually()" title="Ocultar leyenda">‚àí</button></h4>';
            
            // Secci√≥n de √°rboles - Simplificada por categor√≠as
            if (uniqueTreeTypes.length > 0) {
                legendHTML += '<div class="legend-section">';
                legendHTML += '<h5>√Årboles</h5>';
                
                // Verificar si hay √°rboles nuevos
                const hasNewTrees = uniqueTreeTypes.some(type => treeConfig[type]?.category === 'nuevo');
                if (hasNewTrees) {
                    legendHTML += `
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #4caf50"></div>
                            <span>√Årboles Nuevos</span>
                        </div>
                    `;
                }
                
                // Verificar si hay √°rboles existentes
                const hasExistingTrees = uniqueTreeTypes.some(type => treeConfig[type]?.category === 'existente');
                if (hasExistingTrees) {
                    legendHTML += `
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #2196f3"></div>
                            <span>√Årboles Existentes</span>
                        </div>
                    `;
                }
                
                legendHTML += '</div>';
            }
            
            // Secci√≥n de tuber√≠as
            if (uniquePipelineTypes.length > 0) {
                legendHTML += '<div class="legend-section">';
                legendHTML += '<h5>Infraestructura</h5>';
                
                const pipelineColors = {
                    gas: '#ffc107',
                    agua: '#2196f3',
                    electrica: '#ff5722'
                };
                
                const pipelineNames = {
                    gas: 'Tuber√≠a de Gas',
                    agua: 'Tuber√≠a de Agua',
                    electrica: 'Red El√©ctrica'
                };
                
                uniquePipelineTypes.forEach(type => {
                    legendHTML += `
                        <div class="legend-item">
                            <div class="legend-line" style="background-color: ${pipelineColors[type]}"></div>
                            <span>${pipelineNames[type]}</span>
                        </div>
                    `;
                });
                
                legendHTML += '</div>';
            }
            
            // Secci√≥n de √°rea delimitada
            if (polygon.length > 0) {
                legendHTML += '<div class="legend-section">';
                legendHTML += '<h5>√Årea del Proyecto</h5>';
                legendHTML += `
                    <div class="legend-item">
                        <div class="legend-polygon"></div>
                        <span>L√≠mites del Predio</span>
                    </div>
                `;
                legendHTML += '</div>';
            }
            
            legend.innerHTML = legendHTML;
        }

        function exportLegendToPNG() {
            // Verificar si hay datos para generar leyenda
            const uniqueTreeTypes = [...new Set(trees.map(tree => tree.type))];
            const uniquePipelineTypes = [...new Set(pipelines.map(p => p.type))];
            const hasContent = uniqueTreeTypes.length > 0 || uniquePipelineTypes.length > 0 || polygon.length > 0;
            
            if (!hasContent) {
                toastManager.warning('Sin Contenido', 'No hay elementos en el proyecto para crear una leyenda');
                return;
            }
            
            // Crear un canvas para la leyenda
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = 300;
            canvas.height = 400;
            
            // Fondo blanco
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Configurar estilos
            ctx.fillStyle = '#1b5e20';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'left';
            
            let y = 30;
            
            // T√≠tulo
            ctx.fillText('Leyenda del Proyecto', 20, y);
            y += 30;
            
            if (uniqueTreeTypes.length > 0) {
                ctx.font = 'bold 14px Arial';
                ctx.fillText('√Årboles', 20, y);
                y += 20;
                
                ctx.font = '12px Arial';
                
                // Verificar si hay √°rboles nuevos
                const hasNewTrees = uniqueTreeTypes.some(type => treeConfig[type]?.category === 'nuevo');
                if (hasNewTrees) {
                    // Dibujar c√≠rculo verde
                    ctx.fillStyle = '#4caf50';
                    ctx.beginPath();
                    ctx.arc(30, y - 5, 8, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Dibujar texto
                    ctx.fillStyle = '#333';
                    ctx.fillText('√Årboles Nuevos', 50, y);
                    y += 20;
                }
                
                // Verificar si hay √°rboles existentes
                const hasExistingTrees = uniqueTreeTypes.some(type => treeConfig[type]?.category === 'existente');
                if (hasExistingTrees) {
                    // Dibujar c√≠rculo azul
                    ctx.fillStyle = '#2196f3';
                    ctx.beginPath();
                    ctx.arc(30, y - 5, 8, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Dibujar texto
                    ctx.fillStyle = '#333';
                    ctx.fillText('√Årboles Existentes', 50, y);
                    y += 20;
                }
                
                y += 10;
            }
            
            if (uniquePipelineTypes.length > 0) {
                ctx.fillStyle = '#1b5e20';
                ctx.font = 'bold 14px Arial';
                ctx.fillText('Infraestructura', 20, y);
                y += 20;
                
                const pipelineColors = {
                    gas: '#ffc107',
                    agua: '#2196f3',
                    electrica: '#ff5722'
                };
                
                const pipelineNames = {
                    gas: 'Tuber√≠a de Gas',
                    agua: 'Tuber√≠a de Agua',
                    electrica: 'Red El√©ctrica'
                };
                
                ctx.font = '12px Arial';
                uniquePipelineTypes.forEach(type => {
                    // Dibujar l√≠nea de color
                    ctx.strokeStyle = pipelineColors[type];
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(20, y - 5);
                    ctx.lineTo(40, y - 5);
                    ctx.stroke();
                    
                    // Dibujar texto
                    ctx.fillStyle = '#333';
                    ctx.fillText(pipelineNames[type], 50, y);
                    y += 20;
                });
                
                y += 10;
            }
            
            if (polygon.length > 0) {
                ctx.fillStyle = '#1b5e20';
                ctx.font = 'bold 14px Arial';
                ctx.fillText('√Årea del Proyecto', 20, y);
                y += 20;
                
                ctx.font = '12px Arial';
                // Dibujar rect√°ngulo con borde azul
                ctx.strokeStyle = '#007bff';
                ctx.fillStyle = 'rgba(0, 123, 255, 0.2)';
                ctx.lineWidth = 2;
                ctx.fillRect(20, y - 10, 16, 12);
                ctx.strokeRect(20, y - 10, 16, 12);
                
                // Dibujar texto
                ctx.fillStyle = '#333';
                ctx.fillText('L√≠mites del Predio', 50, y);
            }
            
            // Exportar
            canvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${projectName}_leyenda_${new Date().toISOString().split('T')[0]}.png`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                toastManager.success('Leyenda Exportada', 'La leyenda se export√≥ como imagen PNG');
            });
        }

        // Funciones de reporte
        function generateReport() {
            if (trees.length === 0 && pipelines.length === 0 && polygon.length === 0) {
                toastManager.warning('Sin Datos', 'No hay suficientes datos para generar un reporte');
                return;
            }
            
            const modal = document.getElementById('reportModal');
            const content = document.getElementById('reportContent');
            
            let reportHTML = '';
            
            // Informaci√≥n general del proyecto
            reportHTML += `
                <div class="report-section">
                    <h4>üìã Informaci√≥n General</h4>
                    <p><strong>Nombre del Proyecto:</strong> ${projectName}</p>
                    <p><strong>Fecha del Reporte:</strong> ${new Date().toLocaleDateString('es-ES')}</p>
                    <p><strong>Escala Definida:</strong> ${scale ? `1 p√≠xel = ${scale.toFixed(4)} metros` : 'No definida'}</p>
                </div>
            `;
            
            // Informaci√≥n del √°rea
            if (polygon.length > 0) {
                const area = scale ? calculatePolygonArea(polygon, scale) : 0;
                reportHTML += `
                    <div class="report-section">
                        <h4>üó∫Ô∏è √Årea del Proyecto</h4>
                        <p><strong>Puntos del Per√≠metro:</strong> ${polygon.length}</p>
                        ${scale ? `<p><strong>√Årea Total:</strong> ${area.toLocaleString('en-US')} m¬≤ (${(area / 10000).toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})} hect√°reas)</p>` : '<div class="alert alert-warning">Defina la escala para calcular el √°rea</div>'}
                    </div>
                `;
            }
            
            // An√°lisis de √°rboles
            if (trees.length > 0) {
                const treesByCategory = {};
                const treesByDiameter = {};
                
                trees.forEach(tree => {
                    const category = tree.config.category;
                    const diameter = tree.config.diameter;
                    
                    treesByCategory[category] = (treesByCategory[category] || 0) + 1;
                    treesByDiameter[diameter] = (treesByDiameter[diameter] || 0) + 1;
                });
                
                reportHTML += `
                    <div class="report-section">
                        <h4>üå≥ An√°lisis de Vegetaci√≥n</h4>
                        <p><strong>Total de √Årboles:</strong> ${trees.length}</p>
                        
                        <h5>Por Categor√≠a:</h5>
                `;
                
                Object.entries(treesByCategory).forEach(([category, count]) => {
                    const percentage = ((count / trees.length) * 100).toFixed(1);
                    const categoryName = category === 'nuevo' ? 'Nuevos (Plantaci√≥n)' : 'Existentes';
                    reportHTML += `<p>‚Ä¢ ${categoryName}: ${count} √°rboles (${percentage}%)</p>`;
                });
                
                reportHTML += '<h5>Por Di√°metro de Copa:</h5>';
                Object.entries(treesByDiameter)
                    .sort((a, b) => parseInt(a[0]) - parseInt(b[0]))
                    .forEach(([diameter, count]) => {
                        const percentage = ((count / trees.length) * 100).toFixed(1);
                        reportHTML += `<p>‚Ä¢ ${diameter}m de di√°metro: ${count} √°rboles (${percentage}%)</p>`;
                    });
                
                reportHTML += '</div>';
            }
            
            // An√°lisis de infraestructura
            if (pipelines.length > 0) {
                const pipelinesByType = {};
                let totalLength = 0;
                
                pipelines.forEach(pipeline => {
                    const type = pipeline.type;
                    pipelinesByType[type] = (pipelinesByType[type] || 0) + 1;
                    
                    // Calcular longitud si hay escala
                    if (scale && pipeline.points.length > 1) {
                        for (let i = 0; i < pipeline.points.length - 1; i++) {
                            const start = pipeline.points[i];
                            const end = pipeline.points[i + 1];
                            const pixelLength = Math.sqrt(
                                Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2)
                            );
                            totalLength += pixelLength * scale;
                        }
                    }
                });
                
                reportHTML += `
                    <div class="report-section">
                        <h4>üîß Infraestructura</h4>
                        <p><strong>Total de L√≠neas:</strong> ${pipelines.length}</p>
                        ${scale ? `<p><strong>Longitud Total Aproximada:</strong> ${totalLength.toFixed(1)} metros</p>` : ''}
                        
                        <h5>Por Tipo:</h5>
                `;
                
                const typeNames = {
                    gas: 'Tuber√≠as de Gas',
                    agua: 'Tuber√≠as de Agua',
                    electrica: 'Redes El√©ctricas'
                };
                
                Object.entries(pipelinesByType).forEach(([type, count]) => {
                    reportHTML += `<p>‚Ä¢ ${typeNames[type]}: ${count} l√≠neas</p>`;
                });
                
                reportHTML += '</div>';
            }
            
            content.innerHTML = reportHTML;
            modal.style.display = 'block';
            
            toastManager.success('Reporte Generado', 'El an√°lisis del proyecto est√° listo');
        }

        function exportReportToPNG() {
            generateReport();
            
            setTimeout(() => {
                const modal = document.getElementById('reportModal');
                const content = document.getElementById('reportContent');
                
                if (!content.innerHTML.trim()) {
                    toastManager.error('Sin Reporte', 'Primero genera un reporte');
                    return;
                }
                
                // Usar html2canvas ser√≠a ideal aqu√≠, pero por simplicidad crearemos una imagen b√°sica
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = 800;
                canvas.height = 1000;
                
                // Fondo blanco
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // T√≠tulo
                ctx.fillStyle = '#1b5e20';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Reporte de Reforestaci√≥n', canvas.width / 2, 40);
                
                // Informaci√≥n b√°sica
                ctx.font = '16px Arial';
                ctx.textAlign = 'left';
                ctx.fillStyle = '#333';
                
                let y = 80;
                ctx.fillText(`Proyecto: ${projectName}`, 50, y);
                y += 30;
                ctx.fillText(`Fecha: ${new Date().toLocaleDateString('es-ES')}`, 50, y);
                y += 30;
                ctx.fillText(`Total de √Årboles: ${trees.length}`, 50, y);
                y += 30;
                ctx.fillText(`Infraestructura: ${pipelines.length} l√≠neas`, 50, y);
                y += 30;
                
                if (polygon.length > 0 && scale) {
                    const area = calculatePolygonArea(polygon, scale);
                    ctx.fillText(`√Årea: ${area.toLocaleString('es-ES')} m¬≤`, 50, y);
                }
                
                // Exportar
                canvas.toBlob(blob => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${projectName}_reporte_${new Date().toISOString().split('T')[0]}.png`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    toastManager.success('Reporte Exportado', 'El reporte se export√≥ como imagen PNG');
                });
            }, 100);
        }

        function closeModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.style.display = 'none';
            }
        }

        // Eventos de teclado
        document.addEventListener('keydown', function(event) {
            // Prevenir acciones por defecto en ciertas teclas
            if (['Delete', 'Backspace', 'Escape'].includes(event.key)) {
                event.preventDefault();
            }
            
            if (event.key === 'Delete' || event.key === 'Backspace') {
                if (selectedTree && currentMode === 'normal') {
                    const index = trees.indexOf(selectedTree);
                    if (index > -1) {
                        // Guardar estado para undo antes de eliminar
                        saveUndoState(ACTION_TYPES.DELETE_TREE, {
                            tree: JSON.parse(JSON.stringify(selectedTree)),
                            index: index
                        });
                        
                        const treeName = selectedTree.config.name;
                        trees.splice(index, 1);
                        selectedTree = null;
                        updateTreeCount();
                        render();
                        // Actualizar leyenda si est√° visible
                        const legend = document.getElementById('colorLegend');
                        if (legend && !legend.classList.contains('collapsed')) {
                            updateDynamicLegend();
                        }
                        updateStatus('√Årbol eliminado');
                        toastManager.success('√Årbol Eliminado', `${treeName} removido del proyecto`);
                    }
                } else if (selectedPipeline && currentMode === 'normal') {
                    const index = pipelines.indexOf(selectedPipeline);
                    if (index > -1) {
                        // Guardar estado para undo antes de eliminar
                        saveUndoState(ACTION_TYPES.DELETE_PIPELINE, {
                            pipeline: JSON.parse(JSON.stringify(selectedPipeline)),
                            index: index
                        });
                        
                        const pipelineName = selectedPipeline.name;
                        pipelines.splice(index, 1);
                        selectedPipeline = null;
                        updatePipelineInfo();
                        render();
                        // Actualizar leyenda si est√° visible
                        const legend = document.getElementById('colorLegend');
                        if (legend && !legend.classList.contains('collapsed')) {
                            updateDynamicLegend();
                        }
                        updateStatus('Infraestructura eliminada');
                        toastManager.success('Infraestructura Eliminada', `${pipelineName} removida del proyecto`);
                    }
                }
            } else if (event.key === 'z' || event.key === 'Z') {
                if (event.ctrlKey || event.metaKey) {
                    event.preventDefault();
                    if (event.shiftKey) {
                        redo(); // Ctrl+Shift+Z para rehacer
                    } else {
                        undo(); // Ctrl+Z para deshacer
                    }
                }
            } else if (event.key === 'y' || event.key === 'Y') {
                if (event.ctrlKey || event.metaKey) {
                    event.preventDefault();
                    redo(); // Ctrl+Y para rehacer (alternativa)
                }
            } else if (event.key === 'Escape') {
                // Cancelar operaci√≥n actual
                if (currentMode === 'pipeline' && currentPipeline) {
                    currentPipeline = null;
                    previewLine = null; // Limpiar preview
                    toastManager.info('Operaci√≥n Cancelada', 'Dibujo de tuber√≠a cancelado');
                } else if (currentMode === 'polygon') {
                    toastManager.info('Operaci√≥n Cancelada', 'Delimitaci√≥n de √°rea cancelada');
                } else if (currentMode === 'scaling') {
                    scaleLine = null;
                    toastManager.info('Operaci√≥n Cancelada', 'Definici√≥n de escala cancelada');
                } else if (guidelineMode !== 'normal') {
                    currentGuideline = null;
                    previewLine = null; // Limpiar preview
                    guidelineMode = 'normal';
                    toastManager.info('Operaci√≥n Cancelada', 'Dibujo de l√≠nea gu√≠a cancelado');
                }
                currentMode = 'normal';
                selectedTree = null;
                document.getElementById('scaleInfo').style.display = 'none';
                render();
                updateStatus('Operaci√≥n cancelada - Modo normal');
            } else if (event.key === '+' || event.key === '=') {
                if (event.ctrlKey || event.metaKey) {
                    event.preventDefault();
                    zoomIn();
                }
            } else if (event.key === '-') {
                if (event.ctrlKey || event.metaKey) {
                    event.preventDefault();
                    zoomOut();
                }
            } else if (event.key === '0') {
                if (event.ctrlKey || event.metaKey) {
                    event.preventDefault();
                    resetZoom();
                }
            } else if (event.key === 's' || event.key === 'S') {
                if (event.ctrlKey || event.metaKey) {
                    event.preventDefault();
                    exportProject();
                }
            } else if (event.key === 'o' || event.key === 'O') {
                if (event.ctrlKey || event.metaKey) {
                    event.preventDefault();
                    loadProject();
                }
            }
        });

        // Handle Enter key in scale input
        const realLengthInput = document.getElementById('realLength');
        if (realLengthInput) {
            realLengthInput.addEventListener('keypress', function(event) {
                if (event.key === 'Enter') {
                    setScale();
                }
            });
            
            realLengthInput.addEventListener('keydown', function(event) {
                if (['Backspace', 'Delete', 'ArrowLeft', 'ArrowRight', 'Home', 'End'].includes(event.key)) {
                    event.stopPropagation();
                }
            });
        }

        // Handle Enter and Escape keys in project name input
        const projectNameInput = document.getElementById('projectNameInput');
        if (projectNameInput) {
            projectNameInput.addEventListener('keydown', function(event) {
                if (['Backspace', 'Delete', 'ArrowLeft', 'ArrowRight', 'Home', 'End'].includes(event.key)) {
                    event.stopPropagation();
                }
                
                if (event.key === 'Enter') {
                    event.preventDefault();
                    saveProjectName();
                } else if (event.key === 'Escape') {
                    event.preventDefault();
                    cancelEditProjectName();
                }
            });

            projectNameInput.addEventListener('blur', function() {
                if (projectNameInput.style.display !== 'none') {
                    saveProjectName();
                }
            });
        }

        // Context menu prevention
        if (canvas) {
            canvas.addEventListener('contextmenu', function(event) {
                event.preventDefault();
            });
        }

        // Handle visibility change
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                isDragging = false;
                canvas.style.cursor = currentMode === 'normal' ? 'grab' : 'crosshair';
            }
        });

        // Close modal when clicking outside
        window.addEventListener('click', function(event) {
            const modal = document.getElementById('reportModal');
            if (event.target === modal) {
                closeModal('reportModal');
            }
        });

        // Initialize legend on startup
        setTimeout(() => {
            updateDynamicLegend();
        }, 100);

    </script>
</body>
</html>